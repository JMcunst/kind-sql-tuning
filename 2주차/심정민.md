# [친절한 SQL 튜닝 스터디]2장. 인덱스 기본

### 2.1.2 인덱스 구조

인덱스를 사용하면 전체 테이블 스캔 필요없이 범위 스캔(range scan) 가능하다.

범위 스캔이 가능한 이유는 **인덱스는 항상** **정렬돼** **있기** 때문이다.

DBMS는 일반적으로 B+Tree 인덱스 사용한다. (루트+브랜치+리프)

루트와 브랜치 블록에는 키 값을 갖지 않는 특별한 레코드 존재한다. (이를 LMC라고 부른다.)

> LMC
> 

리프 블록에 저장된 각 레코드는 키값 순으로 정렬되어있고, ROWID (테이블 레코드를 가리키는 주소값)을 가짐

- 인덱스 키 값이 같을시 ROWID 순으로 정렬

---

### 2.1.3 인덱스 수직적 탐색, 2.1.4 인덱스 수평적 탐색

### 인덱스 탐색 과정

### **(1) 수직적** **탐색** : 인덱스 스캔 시작지점을 찾는 과정

가장 처음에 **인덱스 스캔 시작지점**을 찾는다.

루트 블록에서 시작 (루트를 포함해 브랜치 블록에 저장된 각 인덱스 레코드는 하위 블록에 대한 주소값을 가짐)

**"조건을 만족하는 첫 번째 레코드"가 목표지점**

### **(2) 수평적** **탐색** : 데이터를 찾는 과정

**리프 블록끼리는 쌍방향 연결리스트 구조** (좌-> 우, 우->좌 로 탐색 가능)

수평적으로 탐색하는  2가지 이유?

1. 조건절을 만족하는 데이터를 모두 찾기 위해
2. ROWID를 얻기 위해 (만약 필요한 컬럼을 인덱스가 모두 갖고있다면 인덱스 스캔만 하지만 일반적으로 인덱스를 스캔하고서 테이블도 액세스한다. 이때 ROWID가 필요)

---

### 2.1.5 결합 인덱스 구조와 탐색

```sql
select 이름, 성별
from 사원
where 성별 = ‘여자’
and 이름 = ‘유관순’
```

### 1. 인덱스를 [성별 + 이름] 순으로 구성한 경우

총 사원 50명 중에서 성별 = ‘여자’인 레코드 25건을 찾고, 거기서 이름을 검사해 최종적으로 2명 출력

- 25번의 검사

### 2. 인덱스를 [이름 + 성별] 순으로 구성한 경우

총 사원 50명 중에서 이름 = ‘유관순＇인 레코드 2건을 찾고, 거기서 성별을 검사해 최종적으로 2명 출력

- 2번의 검사

선택도가 낮은 "이름" 컬럼을 앞쪽에 두고 결합인덱스를 생성해야 검사횟수 줄일 수 있어 성능에 유리하다

**=> 틀린말이다**

인덱스를 [성별 + 이름]으로 하든 [이름+성별] 로 하든 읽는 인덱스 블록 개수가 똑같다.

**인덱스를** **어떻게** **구성하든** **블록 I/O개수가** **같다면** **성능도** **같다.**

위 예제에서 비교 연산 횟수가 줄어드는 건 사실이지만 성능에서 차이는 없다.

---


### 2.2.1 인덱스를 사용한다는 것

인덱스 컬럼(선두 컬럼)을 가공하지 않아야 인덱스를 정상적으로 사용 가능

(=리프 블록에서 스캔 시작점을 찾아 스캔하다가 중간에 멈추는 것을 의미)

***Index Range Scan*** : 리프 블록 일부만 스캔 (인덱스 컬럼 가공하면 Index Range Scan 불가능)

인덱스 컬럼을 가공해도 인덱스 사용 가능하지만, 스캔 시작점을 찾을 수 없고 멈출 수도 없어 리프 블록 전체를 스캔해야만 한다.

***Index Full Scan*** : 리프 블록 전체 스캔

---


### 2.2.2 인덱스를 Range Scan 할 수 없는 이유

"인덱스 컬럼을 가공하면 인덱스를 정상적으로 사용 (Range Scan)할 수 없다"

인덱스 컬럼을 가공하면 인덱스 스캔 시작점을 찾을 수 없기 때문

**#1 인덱스에는 가공되지 않은 값이 저장되어 있음 : 생년월일**

```sql
where substr(생년월일, 5, 2)='05' //생년월일을 substr 함수를 사용해서 가공함
```

가공된 값을 기준으로 검색하려면 스캔 시작점과 스캔 끝지점을 찾을 수 없다.

**#2 가공하지 않은 주문수량으로 인덱스를 만듬**

```sql
where nvl(주문수량,0) < 100 // nvl- 값이 NULL이면 0으로 치환한 값 즉, 가공함
```

**#3 LIKE로 중간값을 검색할 때**

```sql
where 업체명 like '%대한%'
// '대한'을 포함하는 값은 전체 구간에 걸쳐 흩어져있으므로 range scan이 불가능
```

**#4 or 조건으로 검색할 경우**

```sql
where (전화번호 =: tel_no OR 고객명 =: cust_nm)
// 수직적 탐색을 통해 전화번호가 01012345678 이거나
// 고객명이 홍길동인 어느 한 시작지점을 바로 찾을 수 없다.
```

**#5 IN 조건으로 검색할 경우**

```sql
where 전화번호 in (:tel_no1, :tel_no2)
```

IN과 OR은 같다. union all 방식으로 작성하면 각 브랜치 별로 인덱스 스캔 시작점을 찾을 수 있다. (range scan이 가능) OR 과 IN 조건절은 옵티마이저의 쿼리 변환 기능을 통해 Index Range Scan(IS) 로 처리되기도 한다.

OR EXPANSION

```sql
select *
from 고객
where 고객명 =: cust_nm--고객명이 선두 컬럼인 인덱스 Range Scanunion all
select *
from 고객
where 고객명 =: tel_no--전화번호가 선두 컬럼인 인덱스 Range Scanand (고객명<> : cust_nm or 고객명 is null)
```

OR 조건식을 SQL 옵티마이저가 위와 같은 형태로 변환 가능

/*use_concat*/ 힌트를 이용해서 OR EXPANSION 을 유도 가능

---

### 2.2.3 더 중요한 인덱스 사용조건

```sql
select     사원번호, 소속팀, 연령, 입사일자, 전화번호
from     사원
where     사원명 = ‘홍길동＇
```

![](https://blog.kakaocdn.net/dn/FK6cj/btq2N1bAKy9/fh1BFp6Vs1MJ7haJb40Si1/img.png)

인덱스 : [소속팀+사원명+연령]이다.

즉, "데이터를 소속팀 순으로 정렬하고 소속팀이 같으면 사원명 순으로 정렬하고 사원명이 같으면 연령 순으로 정렬한다" (이름이 같은 사원이라도 소속팀이 다르면 서로 멀리 떨어진다 => 그림과 같게됨)

![](https://blog.kakaocdn.net/dn/9gFy9/btq2OqbhRlz/xyYQfB8iKsy2yopXOYPMO0/img.png)

인덱스를 Range Scan 하려면 인덱스 선두 컬럼이 가공되지 않은 상태로 조건절에 있어야 한다.

***결론 : 인덱스 선두 컬럼이 가공되지 않은 상태로 조건절에 있으면 인덱스 Range Scan은 무조건 가능***

*인덱스를 탄다 = 인덱스를 Range Scan 한다*

---

### 2.2.4 인덱스를 이용한 소트 연산 생략

인덱스를 Range Scan 할 수 있는 이유는 데이터가 정렬돼 있기 때문 => 인덱스를 사용하는 이유!

SQL에 ORDER BY 가 있어도 정렬 연산을 따로 수행하지는 않는다.

왜 ??? 인덱스를 스캔하면서 출력한 결과집합이 어차피 변경순번 순으로 정렬되기 때문이다!!

---

### 2.2.5 order by 절에서 컬럼 가공

"인덱스 컬럼을 가공하면 인덱스를 정상적으로 사용 불가능"

여기서 인덱스 컬럼은 where절의 조건을 의미한다!!

그런데 조건절이 아닌 ORDER BY 나 SELECT-LIST에서도 컬럼을 가공함으로써 인덱스를 정상적으로 사용할 수 없는 경우 발생

#1 인덱스 : [장비번호 + 변경일자 + 변경순번]

```sql
SELECT ~~~
ORDER BY 변경일자, 변경순번 //ORDER BY 절 생략 가능 (자동으로 변경일자+변경순번 순으로 정렬되기 때문)

SELECT ~~~
ORDER BY 변경일자 || 변경순번 //ORDER BY 절 생략 불가 (|| : OR)
```

#2 인덱스 : [주문일자 + 주문번호]

```sql
SELECT *
FROM (
         SELECT TO_CHAR( A.주문번호, 'FM00000') AS 주문번호, A. 업체번호, A.주문금액
        FROM 주문 A
        WHERE A.주문일자 =: dt
                AND A.주문번호 > NVL(:next_ord_no, 0)
        ORDER BY 주문번호
        )
WHERE ROWNUM <=30
```

위 질의의 실행 계획을 확인하면 SORT ORDER BY 연산이 추가되어 있다.

인덱스 선두컬럼인 주문일자가 "=" 조건이므로 데이터가 다음 인덱스 컬럼인 주문번호 순으로 출력된다. ORDER BY 절이 있어도 정렬 연산을 생략할 수 있는 상태다.

Q : 그럼에도 불구하고, 왜 SORT ORDER BY 연산이 추가되었을까?

A : ORDERY BY 절에 기술된 주문번호는 순수한 주문번호가 아니라 TO_CHAR 함수로 가공한 주문번호이기 때문이다!!

solution : 진짜 주문번호를 가리키게 주문번호를 명시해준다.

```sql
SELECT *
FROM (
         SELECT TO_CHAR( A.주문번호, 'FM00000') AS 주문번호, A. 업체번호, A.주문금액
        FROM 주문 A
        WHERE A.주문일자 =: dt
                AND A.주문번호 > NVL(:next_ord_no, 0)
        ORDER BY A.주문번호
        )
WHERE ROWNUM <=30
```

다시 실행 계획을 확인해보면 sort order by가 출력되지 않는 것을 확인할 수 있다.

---

### 2.2.6 select-list 에서 컬럼 가공

인덱스 : [장비번호 + 변경일자 + 변경순번]

```sql
select min(변경순번)
from 상태변경이력
where 장비번호='C'
	and 변경일자='2180316';
```

정렬연산을 따로 하지 않음 , 수직적 탐색을 통해 조건을 만족하는 가장 왼쪽 지점으로 내려가서 첫 번째 읽는 레코드가 바로 최소값

```sql
select max(변경순번)
from 상태변경이력
where 장비번호='C'
	and 변경일자='2180316';
```

정렬연산을 따로 하지 않음, 수직적 탐색을 통해 가장 오른쪽 지점으로 내려감

```sql
select nvl(max(to_number(변경순번)),0)
from 상태변경이력
where 장비번호='C'
	and 변경일자='2180316';.
```

인덱스에는 문자열 기준으로 정렬되어있지만, 숫자값으로 바꾼 값 기준으로 최종 변경 순번을 요구하면 **정렬연산 발생**! (select 절에서 to_number함수를 사용해 변경순번을 가공했기 때문에)

```sql
select nvl(to_number(max(변경순번)),0)
from 상태변경이력
where 장비번호='C'
	and 변경일자='2180316';
```

정렬연산없이 최종 변경순번을 쉽게 찾을 수있다. (max 값을 가장 먼저 찾았기 때문에)

---

### 2.3.1 Index Range Scan

Index Range Scan은 B*Tree 인덱스의 가장 일반적인 정상적인 형태의 액세스 방식이다.

Index Range Scan을 하려면 선두 컬럼을 가공하지 않은 상태로 **조건절**에 사용한다.

(즉, 선두컬럼을 가공하지 않은 상태로 **조건절**에 사용하면 Index Range Scan은 무조건 가능하다.)

그러나 인덱스 잘타니까 성능도 OK 는 아니다!

성능은 인덱스 스캔 범위, 테이블 액세스 횟수등을 얼마나 줄일 수 있는가? 에 따라 달라진다.

---

### 2.3.2 Index Full Scan

**Index Full Scan은 수직적 탐색 없이** 인덱스 리프 블록을 처음부터 끝까지 수평적으로 탐색한다.

데이터 검색을 위한 최적의 인덱스가 없을 때 차선으로 선택한다. (최적의 인덱스가 존재한다면 Index Range Scan)

```sql
index (ename, sal)

select * from emp
where sal > 2000
order by ename;
// 이럴 때, index full scan 발생
```

인덱스 선두컬럼인 **ename**이 where 조건절에 없기 때문에 **index range scan** 불가능하다.

두번째에 있는 **sal**로 **index full scan**이 일어난다.

---

### 2.3.3 Index Unique Scan

*"정확히 딱 해당되는 값을 찾을 때"*

**Index Unique Scan**은 **수직적 탐색으로만** 데이터를 찾는 스캔 방식이다.

Unique Index를 = 조건을 탐색하는 경우에 작동한다.

(Unique Index가 존재하는 컬럼은 중복값이 입력되지 않게 dbms가 데이터 정합성을 관리한다.)

=> 해당 인덱스 키 컬럼을 모두 **'=' 조건**으로 검색할 때는 데이터를 한 건 찾는 순간 더 이상 탐색할 필요가 없다. (중복되는 값 없으니깐)

**Unique Index**라도 empno >= 7888 처럼 범위검색으로 검색하게되면 **Index Range Scan**으로 처리된다.

수직적 탐색으로는 조건에 해당하는 레코드를 모두 찾을 수 없기 때문이다.

**PK인덱스**가 [주문일자+고객ID+상품ID]이지만, 주문일자와 고객ID 두 개만가지고 검색하면 **Index Range Scan**

---

### 2.3.4 Index Skip Scan

*인덱스 선두 컬럼을 조건절에서 사용하지 않으면, 옵티마이저는 기본적으로 Table Full Scan을 선택한다.*

Table Full Scan 보다 IO를 줄일 수있거나 정렬된 결과를 쉽게 얻을 수 있다면, Index Full Scan 사용한다.

**Index Skip Scan**

- **인덱스 선두 컬럼의 distinct value개수가 적고 후행 컬럼의 distinct value 개수가 많을 경우 유용**

(distinct value가 적다는것은 '남', '여'처럼 보기가 별로 없다는 것)

```sql
create index idx1 on emp(sex,salary);

select *
from emp
where sex='남' and salary between 2000 and 4000;

select/*+ index_ss(idx1)*/ *
from emp
where salary between 2000 and 4000;
```

- 첫번째 쿼리는 index range scan
- 두번째 쿼리는 **힌트를** 사용하여 index skip scan을 유도한 경우이다.

*index skip scan은 루트 또는 브랜치 블록에서 읽은 컬럼 값 정보를 이용해 조건절에 부합하는 레코드를 포함할 '가능성이 있는' 리프 블록만 골라서 액세스하는 스캔 방식이다.*

(예측한다? 라는 표현이 잘 맞는듯?)

**<Index Skip Scan이 작동하기 위한 조건>**

Distict Value 개수가 적은 선두 컬럼이 조건절에 없고, 후행 컬럼이 distinct value 개수가 많을 때 효과적이다.

그러나, 인덱스 선두 컬럼이 없을 때만 index skip scan이 작동하는 것은 아니다.

- *ex1) 선두컬럼에 대한 조건절(업종유형코드)은 있지만 중간 컬럼(업종코드)에 대한 조건절이 없는 경우*

```sql
select/*+ INDEX_SS(A index1_pk) */
        기준일자, 업종코드, 체결건수, 체결수량, 거래대금
from 일별업종거래 A
where 업종유형코드='01'
and 기준일자 between '20080501' and '20080531'
```

index1_pk : [업종유형코드 + 업종코드 + 기준일자]

**index range scan**의 경우 업종유형코드='01'인 인덱스 구간을 모두 스캔`

**index skip scan**을 사용한다면 업종유형코드='01'인 구간에서 기준일자가 해당 범위에 있는 **레코드를 포함할 가능성이 있는 리프 블록만 골라서 액세스**

- *ex2) distinct value가 적은 두개의 선두컬럼이 모두 조건절에 없는 경우*

```sql
select/*+ INDEX_SS(A index1_pk) */
        기준일자, 업종코드, 체결건수, 체결수량, 거래대금
from 일별업종거래 A
where 기준일자 between '20080501' and '20080531'
```

- *ex3) between , like 와 같은 범위검색 조건일 때도 Index Skip Scan 사용 가능*

인덱스 : 기준일자 +업종유형코드

```sql
select/*+ INDEX_SS(A index1_pk) */
        기준일자, 업종코드, 체결건수, 체결수량, 거래대금
from 일별업종거래 A
where 기준일자 between '20080501' and '20080531'
and 업종유형코드='01'
```

만약 **index range scan**을 사용하는 경우 between 조건을 만족하는 범위를 모두 스캔함

**index skip scan**을 사용하는 경우 between 조건을 만족하는 인덱스 구간에서 업종유형코드='01'인 에코드를 '포함할 가능성이 있는 리프 블록만' 골라서 액세스 가능

---

### 2.3.5 Index Fast Full Scan

Index Fast Full Scan 이 Index Full Scan 보다 빠른이유

: 논리적인 인덱스 트리 구조를 무시하고 인덱스세그먼트 전체를 **Multiblock IO 방식**으로 스캔하기 때문이다,

Multiblock IO 방식 사용

인덱스가 파티션 돼 있지 않더라도 병렬 쿼리가 가능

병렬 쿼리시에는 Direct Path IO 방식을 사용

| Index  Full Scan | Index  Fast Full Scan |
| --- | --- |
| 인덱스를 구조에 따라 스캔 | 세그먼트 전체를 스캔결과집합 순서 보장 안됨Multiblock IO병렬스캔 가능인덱스에 포함된 컬럼으로만 조회할 때 사용 가능 |
| 결과집합 순서 보장 | 결과집합 순서 보장 안됨 |
| Single Block IO | Multiblock IO |
| (파티션 돼 있지 않다면) 병렬 스캔 불가 | 병렬스캔 가능 |
| 인덱스에 포함되지 않은 컬럼 조회 시에도 사용 가능 | 인덱스에 포함된 컬럼으로만 조회할 때 사용 가능 |

---

### 2.3.6 Index Range Scan Descending

Index Range Scan과 기본적으로 동일한 스캔 방식이다.

인덱스를 뒤에서부터 앞쪽으로 스캔하기 때문에 **내림차순**으로 정렬된 결과집합을 얻을 수 있다.
