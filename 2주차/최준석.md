# 2장. 인덱스 기본

## 2.1 인덱스 구조 및 탐색

### 데이터 검색 방법

데이터를 찾는 방법은 크게 두 가지입니다. 테이블 전체를 스캔하거나 인덱스를 이용하는 것입니다. OLTP 시스템에서는 소량 데이터를 주로 검색하므로 인덱스 튜닝이 중요합니다.

### 인덱스 튜닝의 핵심요소

인덱스 튜닝의 핵심요소는 두 가지입니다.

- 첫째, 인덱스 스캔 효율화 튜닝으로 인덱스 스캔 과정에서 발생하는 비효율을 줄이는 것입니다.
- 둘째, 랜덤 액세스 최소화 튜닝으로 테이블 액세스 횟수를 줄이는 것입니다.

인덱스 스캔 후 테이블 레코드를 액세스할 때 랜덤 I/O 방식을 사용하는데, 첫 번째보다 두 번째가 성능에 미치는 영향이 더 크므로 중요합니다.

### SQL 튜닝과 랜덤 I/O

SQL 튜닝은 랜덤 I/O와의 전쟁입니다. 데이터베이스 성능이 느린 이유는 디스크 I/O 때문입니다. 읽어야 할 데이터량이 많고, 그 과정에 디스크 I/O가 많이 발생할 때 느립니다. 인덱스를 많이 사용하는 OLTP 시스템이라면 디스크 I/O 중에서도 랜덤 I/O가 특히 중요합니다.

### 인덱스 구조

인덱스는 B\*Tree 구조로 되어 있으며, 정렬되어 있습니다.

- 루트(Root), 브랜치(Branch), 리프(Leaf) 블록으로 구성됩니다.
- 루트와 브랜치 블록에 저장된 각 인덱스 레코드는 하위 블록에 대한 주소값을 갖습니다.
- LMC(Leftmost Child)는 자식 노드 중 가장 왼쪽 끝에 위치한 블록을 가리킵니다.
- 리프 블록에 저장된 각 레코드는 키값 순으로 정렬되어 있고, 테이블 레코드를 가리키는 주소값, 즉 ROWID를 갖습니다.
- 인덱스 키값이 같으면 ROWID 순으로 정렬됩니다.

### ROWID 구성

ROWID는 데이터 블록 주소와 로우 번호로 구성됩니다.

- 데이터 블록 주소는 데이터 파일번호와 블록 번호로 구성됩니다.
- 블록 번호는 데이터 파일 내에서 부여한 상대적 순번이고, 로우 번호는 블록 내 순번입니다.

### 인덱스 수직적 탐색

인덱스 수직적 탐색은 정렬된 인덱스 레코드 중 조건을 만족하는 첫 번째 레코드를 찾는 과정입니다. 즉, 인덱스 스캔 시작지점을 찾는 과정입니다.

- 수직적 탐색은 루트 블록에서부터 시작합니다.
- 루트를 포함해 브랜치 블록에 저장된 각 인덱스 레코드는 하위 블록에 대한 주소값을 갖습니다.
- 루트에서 시작해 리프 블록까지 수직적 탐색이 가능한 이유입니다.
- 중요한 점은 수직적 탐색은 '조건을 만족하는 레코드'를 찾는 과정이 아니라 '조건을 만족하는 첫 번째 레코드'를 찾는 과정입니다.

### 인덱스 수평적 탐색

인덱스 수평적 탐색은 수직적 탐색으로 찾은 인덱스부터 정렬된 인덱스를 따라 스캔하는 과정입니다. 조건을 만족하는 데이터를 찾는 과정입니다.

- 수직적 탐색을 통해 스캔 시작점을 찾았으면, 찾고자 하는 데이터가 더 안 나타날 때까지 인덱스 리프 블록을 수평적으로 스캔합니다.
- 인덱스에서 본격적으로 데이터를 찾는 과정입니다.
- 인덱스 리프 블록끼리는 서로 앞뒤 블록에 대한 주소값을 갖습니다. 즉, 양방향 연결 리스트(double linked list) 구조입니다.
- 좌에서 우로, 또는 우에서 좌로 수평적 탐색이 가능한 이유입니다.

### 수평적 탐색의 목적

인덱스를 수평적으로 탐색하는 이유는 다음과 같습니다:

1. 조건절에 만족하는 데이터를 모두 찾기 위해서
2. ROWID를 얻기 위해서

필요한 컬럼을 인덱스가 모두 갖고 있어 인덱스만 스캔하고 끝나는 경우도 있지만, 일반적으로 인덱스를 스캔하고서 테이블도 액세스합니다. 이 때 ROWID가 필요합니다.

### 결합 인덱스 구조와 특성

두 개 이상 컬럼을 결합해서 인덱스를 만들 수도 있습니다. 결합 인덱스의 중요한 특성은 고객 테이블에 성별과 고객명 기준으로 만든 인덱스 구조에서 인덱스를 [고객명 + 성별]로 구성하든, [성별 + 고객명]으로 구성하든 읽는 인덱스 블록 개수가 똑같다는 사실입니다.

DBMS가 사용하는 B\*Tree 인덱스는 엑셀 필터링처럼 동작하는 것이 아니라 루트에서 브랜치를 거쳐 리프 블록까지 탐색하면서 모든 컬럼 조건을 만족하는 블록을 탐색합니다. 따라서 어느 컬럼을 앞에 두든 일량(읽는 블록 수)에는 차이가 없습니다.

### 인덱스 구성에 따른 성능 차이

하지만 인덱스 구성에 따라 성능 차이는 있을 수 있습니다. 예를 들어, 다음과 같은 쿼리에서:

```sql
SELECT *
FROM 고객
WHERE 고객명 = '홍길동'
AND 시력 BETWEEN 1.0 AND 1.5;
```

고객명과 시력으로 구성된 결합 인덱스가 있다면, 고객명이 선두 컬럼인 경우 홍길동이라는 소량의 데이터만 스캔하면 됩니다. 반면 시력이 선두 컬럼인 경우 시력이 1.0~1.5인 사람을 모두 스캔해야 합니다.

### ORDER BY와 컬럼 가공

ORDER BY 절에서 컬럼을 가공하면 정렬 연산을 생략할 수 없습니다:

```sql
SELECT *
FROM 고객
WHERE 고객명 = '홍길동'
ORDER BY 지역 || 등급;
```

위 쿼리는 고객명, 지역, 등급으로 구성된 인덱스가 있더라도 ORDER BY 절에서 컬럼을 가공했기 때문에 정렬 연산이 필요합니다.

### SELECT-LIST에서의 컬럼 가공

SELECT-LIST에서 컬럼 가공도 문제가 될 수 있습니다:

```sql
SELECT NVL(MAX(TO_NUMBER(고객번호)), 0)
FROM 고객
WHERE 지역 = '서울'
AND 가입일자 = '20180316';
```

인덱스에는 문자열 기준으로 정렬돼 있는데, 이를 숫자값으로 바꾸려 했기 때문입니다. 이를 정렬 연산 없이 최종 고객번호를 쉽게 찾으려면 아래와 같이 수정하면 됩니다:

```sql
SELECT NVL(TO_NUMBER(MAX(고객번호)), 0)
FROM 고객
WHERE 지역 = '서울'
AND 가입일자 = '20180316';
```

### 인덱스 Range Scan 조건

인덱스를 Range Scan하기 위한 가장 첫 번째 조건은 인덱스 선두 컬럼이 조건절에 있어야 합니다. 예를 들어, 결합 인덱스 (지역, 고객명, 가입일자)에 대하여 질의문에 고객명만을 명시한 경우:

```sql
SELECT *
FROM 고객
WHERE 고객명 = '홍길동';
```

B\*Tree 구조는 지역, 고객명, 가입일자 순서로 정렬되어 있기 때문에 고객명 조건만을 만족하는 블록은 순서를 보장할 수 없습니다.

### 랜덤 액세스 최소화의 중요성

인덱스 튜닝에서 가장 중요한 것은 랜덤 액세스를 최소화하는 것입니다. 인덱스를 통해 테이블에 접근할 때 발생하는 랜덤 I/O는 성능에 큰 영향을 미칩니다. 따라서 인덱스 스캔 후 테이블에 접근하는 유효 인덱스가 적을수록 효율적입니다. 예를 들어:

```sql
SELECT *
FROM 고객
WHERE 지역 = '서울'
AND 고객명 LIKE '홍%'
AND 가입일자 BETWEEN '20180101' AND '20180131';
```

위 쿼리에서 (지역, 고객명, 가입일자) 인덱스를 사용할 때, 1,000건의 인덱스 레코드를 읽고 그중 100건만 테이블에 접근한다면 효율적이지만, 1,000건 모두 테이블에 접근한다면 비효율적입니다.
