# 5.1장 소트 연산에 대한 이해

소트, 그루핑하는 과정을 알아보자

## 1. 소트 수행 과정

소트는 기본적으로 PGA에 할당된 Sort Area에서 이루어짐. (최적)

공간이 다 차면 temp 테이블 스페이스 사용.

sort의 두가지 유형

- 메모리 소트: 전체 데이터의 정렬 작업을 메모리 내에서 완료하는 것 (internal sort)
- 디스크 소트: 할당받은 sort area 내에서 정렬을 완료하지 못해 디스크 공간까지 사용하는 경우 (external sort)

디스크 소트가 발생하면 SQL 수행 성능은 나빠진다. 많은 서버 리소스를 사용하고 부분범위 처리도 불가능하기 때문에 애플리케이션 성능을 저하시키는 주요인이 된다.

따라서, 될 수 있으면 소트가 발생하지 않도록 하고, 필요하다면 **메모리 내에서 수행을 완료할 수 있도록** 해야 한다.

## 2. Sort Operation

sort를 발생시키는 오퍼레이션은 다음과 같다.

1. **Sort Aggregate**

`select sum(sal), max(sal), min(sal), avg(sal) from emp;`

전체 로우를 대상으로 집계를 수행할 때 사용된다. 실제로 데이터를 정렬하진 않고, sort area를 사용한다는 의미이다.

2. **Sort Order By**

`select * from emp order by sal desc;`

데이터를 정렬할 때 사용된다.

3. **Sort Group By**

`select deptno, sum(sal), max(sal), min(sal), avg(sal) from emp
group by deptno order by deptno;`

소팅 알고리즘을 사용해 그룹별 집계를 수행할 때 사용된다.

4. **Sort Unique**

`select job, mgr from emp where deptno = 10;`

서브 쿼리에서 메인 쿼리와 조인하기 전에 중복 레코드를 제거하는 경우 사용된다.

# 5.2장 소트가 발생하지 않도록 SQL 작성

SQL 작성할 때 불필요한 소트가 발생하지 않도록 주의해야 한다. union, minus, distinct 연산자는 중복 레코드를 제거하기 위해 소트 연산을 발생시키므로 꼭 필요한 경우에만 사용하자.

## 1. Union vs Union All

- union: 두 집합 간 중복을 제거하려고 소트 작업을 수행
- union all: 두 집합을 단순히 결합

→ 둘 중 사용을 고민한다면, 소트 연산이 없는 union all을 사용하자.

중복이 없는 데이터라면, union all 을 사용해도 union 과 같은 결과를 반환하므로 이런 경우에 사용하면 좋다.

## 2. Exists

distinct는 조건에 해당하는 데이터를 모두 읽어서 중복을 제거하므로 그 과정에서 많은 i/o가 발생한다.

```sql
SELECT DISTINCT P.상품번호, P.상품명, P.상품가격, ...
  FROM 상품 P, 계약 C
 WHERE P.상품유형코드 = :pclscd
   AND C.상품번호 = P.상품번호
   AND C.계약일자 BETWEEN :DT1 AND :DT2
   AND C.계약구분코드 = :CTPCD

SELECT P.상품번호, P.상품명, P.상품가격, ...
  FROM 상품 P
 WHERE P.상품유형코드 = :pclscd
   AND EXISTS ( SELECT 'X' FROM 계약 C
                 WHERE C.상품번호 = P.상품번호
                   AND C.계약일자 BETWEEN :DT1 AND :DT2
                   AND C.계약구분코드 = :CTPCD)
```

exists 서브쿼리는 데이터 존재 여부만 확인하면 되므로 조건절을 만족하는 데이터를 모두 읽지 않는다. distinct 연산자를 사용하지 않았으므로 상품 테이블에 대한 부분범위 처리도 가능하다.

distinct, minus 연산자를 사용한 쿼리는 대부분 exists 서브쿼리로 변환 가능하므로 기억해두자.

## 3. 조인 방식 변경

조인 방식에 따라 소트 연산이 바뀌기도 하므로 잘 선택해야 한다.

두 테이블이 NL 조인하도록 조인 방식을 변경하면 소트 연산을 생략해 부분범위 처리 가능한 상황에서 큰 성능 개선 효과를 얻을 수 있다.

예시 : 계약_X01 인덱스 ⇒ [지점 ID + 계약일시]

```sql
SELECT C.계약번호, C.상품코드, P.상품명, P.상품구분코드, C.계약일시, C.계약금액
  FROM 계약 C, 상품 P
 WHERE C.지점ID = :brch_id
   AND P.상품코드 = C.상품코드
 ORDER BY C.계약일시 DESC
```

위의 쿼리 같은 경우는 인덱스를 사용한다고 해도 해시 조인이라 Sort Order by가 발생한다.

```sql
SELECT /*+ leading(C) use_nl(P) */
       C.계약번호, C.상품코드, P.상품명, P.상품구분코드, C.계약일시, C.계약금액
  FROM 계약 C, 상품 P
 WHERE C.지점ID = :brch_id
   AND P.상품코드 = C.상품코드
 ORDER BY C.계약일시 DESC
```

힌트로 정렬 기준을 조인 키로 설정해 인덱스를 사용하여 sort 연산을 생략했다.

# 5.3장 인덱스를 이용한 소트 연산 생략

인덱스를 활용하면 정렬이나 그룹화가 있어도 소트 연산을 생략할 수 있다.

## 1. Sort Order By 생략

```sql
SELECT 거래일시, 체결건수, 체결수량, 거래대금
  FROM 종목거래
 WHERE 종목코드 = 'KR123456'
 ORDER BY 거래일시
```

인덱스 선두 컬럼을 [종목코드+거래일시] 순으로 구성하면 소트 연산을 생략할 수 있다.

**부분범위 처리를 활용하여 튜닝하자.**

부분범위 처리는 쿼리 수행 결과 중 앞쪽 일부를 우선 전송하고, 남은 데이터를 나눠 전송하는 방식을 말한다. 이 방식은 상위 n개를 조회하는 Top N 쿼리에서 성능을 발휘한다.

 

## 2. Top N 쿼리

```sql
SELECT 거래일시, 체결건수, 체결수량, 거래대금
  FROM 종목거래
 WHERE 종목코드 = 'KR123456'
   AND 거래일시 >= '20180304'
 ORDER BY 거래일시
 LIMIT 10 OFFSET 0;
```

조건에 해당하는 레코드의 집합을 모두 읽어 거래일시 순으로 정렬한 중간 집합을 만들고, 상위 레코드를 조회하는 방식을 가진다. 여기서 인덱스 선두 컬럼을 [종목코드+거래일시] 순으로 구성한다면, 정렬을 생략할 것이다. 레코드가 아무리 많아도 N개를 읽는 순간 바로 멈춘다는 뜻이다.
=======
## 5.3 인덱스를 이용한 소트 연산 생략

### 핵심 개념 정리

**인덱스를 활용한 소트 제거의 중요성**
인덱스는 항상 키 컬럼 순으로 정렬된 상태를 유지하므로, 이를 이용해 `ORDER BY` 절에서 발생하는 소트 오퍼레이션을 생략할 수 있음. 이는 특히 부분범위 처리 상황에서 극적인 성능 개선을 가져다줌.

**소트 생략을 위한 조건**
ORDER BY 절의 정렬 순서와 인덱스의 구성 순서가 일치해야 함. 즉, 쿼리에서 요구하는 정렬 방식이 인덱스가 이미 제공하는 정렬 상태와 동일해야 소트 연산을 생략할 수 있음.

## 5.3.1 Sort Order By 생략

### Sort Order By 생략 원리

**기본 원리**
ORDER BY 절에 사용된 컬럼들이 인덱스의 선두 컬럼부터 순서대로 구성되어 있으면, 옵티마이저는 `SORT (ORDER BY)` 오퍼레이션을 생략하고 인덱스 스캔만으로 정렬된 결과를 반환함.

**효과적인 인덱스 구성**

```sql
-- AS-IS: 소트 연산이 발생하는 경우
-- [거래일시] 인덱스만 존재할 때
SELECT 거래일시, 체결건수, 체결수량, 거래대금
  FROM 종목거래
 WHERE 종목코드 = 'KR123456'
 ORDER BY 거래일시;
-- 실행계획: TABLE ACCESS (FULL) → SORT (ORDER BY)

-- TO-BE: 소트 연산을 생략하는 경우
-- [종목코드 + 거래일시] 인덱스 구성
-- 실행계획: INDEX (RANGE SCAN) → TABLE ACCESS (BY INDEX ROWID)
```

**튜닝 포인트**

- WHERE 절의 조건 컬럼과 ORDER BY 절의 정렬 컬럼을 함께 고려하여 인덱스를 구성해야 함
- 인덱스 선두 컬럼부터 ORDER BY 절에 명시된 순서와 일치해야 함
- 내림차순(DESC) 정렬도 인덱스를 활용할 수 있음 (인덱스를 역순으로 스캔)

### 부분범위 처리와의 관계

**부분범위 처리의 정의**
쿼리 수행 결과 중 앞쪽 일부를 우선 전송하고 멈췄다가, 클라이언트가 추가 전송을 요청(Fetch Call)할 때마다 남은 데이터를 조금씩 나누어 전송하는 방식임.

**3-Tier 환경에서의 제약**
서버 리소스를 수많은 클라이언트가 공유하는 구조이므로 클라이언트가 특정 DB 커넥션을 독점할 수 없음. 단위 작업을 마치면 DB 커넥션을 커넥션 풀에 반환해야 하므로 쿼리 조회 결과를 클라이언트에게 '모두' 전송하고 커서(Cursor)를 닫아야 함.

**페이징 처리에서의 활용**
3-Tier 환경에서는 페이징 처리 기법을 통해 부분범위 처리의 이점을 활용함. 적절한 인덱스 구성으로 소트 연산을 생략하면 페이징 처리에서도 우수한 성능을 얻을 수 있음.

## 5.3.2 Top N 쿼리

### Top N 쿼리의 정의

전체 결과집합 중 상위 N개 레코드만 선택하는 쿼리임. DBMS별로 다른 문법을 제공함.

**DBMS별 Top N 쿼리 문법**

```sql
-- SQL Server
SELECT TOP 10 거래일시, 체결건수, 체결수량, 거래대금
  FROM 종목거래
 WHERE 종목코드 = 'KR123456'
   AND 거래일시 >= '20180304'
 ORDER BY 거래일시;

-- PostgreSQL/DB2
SELECT 거래일시, 체결건수, 체결수량, 거래대금
  FROM 종목거래
 WHERE 종목코드 = 'KR123456'
   AND 거래일시 >= '20180304'
 ORDER BY 거래일시
FETCH FIRST 10 ROWS ONLY;

-- Oracle
SELECT *
  FROM (SELECT 거래일시, 체결건수, 체결수량, 거래대금
          FROM 종목거래
         WHERE 종목코드 = 'KR123456'
           AND 거래일시 >= '20180304'
         ORDER BY 거래일시)
 WHERE ROWNUM <= 10;
```

### Top N 소트 알고리즘

**COUNT(STOPKEY) 오퍼레이션**
조건절에 부합하는 레코드가 아무리 많아도 그 중 ROWNUM으로 지정한 건수만큼 결과 레코드를 얻으면 거기서 바로 멈춘다는 뜻임.

**인덱스를 활용한 Top N 쿼리의 효율성**

- **소트 연산 생략**: [종목코드 + 거래일시] 인덱스가 있으면 `SORT (ORDER BY)` 오퍼레이션이 완전히 생략됨
- **조기 종료**: 인덱스를 스캔하다가 10개 레코드를 읽는 순간 바로 멈춤
- **부분범위 처리**: 전체 레코드를 읽을 필요가 없으므로 부분범위 처리 상황에서 매우 중요한 성능 이점을 제공함

**인덱스가 없는 경우의 처리**
인덱스로 소트 연산을 생략할 수 없어 Table Full Scan 방식일 때는 `SORT ORDER BY STOPKEY`를 사용함. Top N 소트 알고리즘이 작동하여 전체 데이터를 모두 정렬하지 않고 상위 N개만 유지하면서 정렬하므로 소트 부하를 최소화할 수 있음.

### 페이징 처리 최적화

**페이징 처리용 표준 패턴**

```sql
-- 3-Tier 환경에서 페이징 처리 표준 패턴
SELECT *
  FROM (SELECT ROWNUM NO, A.*
          FROM (SELECT 거래일시, 체결건수, 체결수량, 거래대금
                  FROM 종목거래
                 WHERE 종목코드 = 'KR123456'
                   AND 거래일시 >= '20180304'
                 ORDER BY 거래일시) A
         WHERE ROWNUM <= (:page * 10))
 WHERE NO >= (:page-1) * 10 + 1;
```

**페이징 처리 최적화 조건**

1. 인덱스 사용 가능하도록 조건절 구성
2. 조인은 NL 조인 위주로 처리 (룩업을 위한 작은 테이블을 해시 조인 Build Input으로 처리해도 됨)
3. ORDER BY 절이 있어도 소트 연산을 생략할 수 있도록 인덱스 구성

## 5.3.3 최솟값/최댓값 구하기

### 일반적인 MIN/MAX 처리 방식

**Sort Aggregate 오퍼레이션**
최솟값(MIN), 최댓값(MAX)을 구하는 SQL 실행계획에서 `Sort Aggregate` 오퍼레이션이 나타남. Sort Aggregate는 전체 데이터를 정렬하지는 않지만, 전체 데이터를 읽으면서 값을 비교하는 방식임.

```sql
-- 비효율적인 MIN/MAX 처리
SELECT MAX(SAL) FROM EMP;

-- 실행계획
0 SELECT STATEMENT Optimizer=ALL_ROWS
1 0 SORT (AGGREGATE)
2 1 TABLE ACCESS (FULL) OF 'EMP' (TABLE)
```

### 인덱스를 활용한 MIN/MAX 최적화

**인덱스 활용의 이점**
인덱스는 정렬되어 있으므로 전체 데이터를 읽지 않고 최솟값과 최댓값을 쉽게 찾을 수 있음.

**최적화된 처리 방식**

- **MIN 값 구하기**: 인덱스의 가장 왼쪽(첫 번째) 레코드 1개만 읽고 멈춤
- **MAX 값 구하기**: 인덱스의 가장 오른쪽(마지막) 레코드 1개만 읽고 멈춤

**튜닝 가이드**

1. MIN/MAX 함수에 사용되는 컬럼에 인덱스를 생성
2. 해당 컬럼이 복합 인덱스의 일부라면, 가능한 한 선두 컬럼에 위치시키거나 조건절과 함께 고려하여 인덱스 구성
3. 윈도우 함수 중 `RANK`, `ROW_NUMBER` 함수는 `MAX` 함수보다 소트 부하가 적으므로 상황에 따라 활용 고려

**성능 비교**
인덱스를 활용하면 수십만 건의 데이터에서 MIN/MAX를 구할 때도 1~2개 블록만 읽으면 되므로, Table Full Scan 방식 대비 수천 배의 성능 향상을 기대할 수 있음.

## 5.3.4 이력 조회

### 이력 테이블의 특성

**이력 테이블의 정의**
시간의 흐름에 따라 데이터의 변화를 추적하기 위해 과거 데이터를 모두 보관하는 테이블임. 일반적으로 [기본키 + 변경일시] 형태의 복합 인덱스를 가짐.

**일반적인 이력 조회 패턴**

1. **최근 이력 조회**: 각 항목별로 가장 최근의 이력 데이터를 조회
2. **특정 시점 이력 조회**: 특정 시점(기준일시) 현재 유효했던 이력 데이터를 조회
3. **기간별 이력 조회**: 특정 기간 동안의 모든 이력 변화를 조회

### 최근 이력 조회 최적화

**비효율적인 방법**

```sql
-- 서브쿼리를 이용한 방법 (비효율적)
SELECT *
  FROM 상품이력 A
 WHERE 변경일시 = (SELECT MAX(변경일시)
                   FROM 상품이력 B
                  WHERE B.상품코드 = A.상품코드);
```

**효율적인 방법: 윈도우 함수 활용**

```sql
-- 윈도우 함수를 이용한 방법 (효율적)
SELECT *
  FROM (SELECT 상품코드, 상품명, 가격, 변경일시,
               ROW_NUMBER() OVER (PARTITION BY 상품코드 ORDER BY 변경일시 DESC) RN
          FROM 상품이력)
 WHERE RN = 1;
```

**최적 인덱스 구성**
[상품코드 + 변경일시 DESC] 인덱스를 구성하면 각 상품별로 최근 데이터부터 정렬된 상태로 저장되어 ROW_NUMBER() 함수의 소트 부하를 최소화할 수 있음.

### 특정 시점 이력 조회

**기준일시 이하 최대값 조회**

```sql
-- 2024-01-15 현재 유효한 상품 정보 조회
SELECT *
  FROM (SELECT 상품코드, 상품명, 가격, 변경일시,
               ROW_NUMBER() OVER (PARTITION BY 상품코드
                                  ORDER BY 변경일시 DESC) RN
          FROM 상품이력
         WHERE 변경일시 <= '2024-01-15')
 WHERE RN = 1;
```

**튜닝 포인트**
[상품코드 + 변경일시] 인덱스가 있으면 각 상품별로 조건을 만족하는 첫 번째 레코드만 읽고 바로 다음 상품으로 이동할 수 있어 매우 효율적임.

## 5.3.5 Sort Group By 생략

### Group By 연산의 기본 처리 방식

**Sort Group By 연산**
일반적으로 GROUP BY 절이 있는 쿼리는 먼저 GROUP BY 컬럼을 기준으로 데이터를 정렬한 후, 정렬된 순서대로 그룹핑을 수행함. 이때 `Sort Group By` 오퍼레이션이 실행계획에 나타남.

### 인덱스를 활용한 Group By 최적화

**Sort Group By 생략 조건**
GROUP BY 절에 사용된 컬럼이 인덱스의 선두 컬럼과 순서까지 일치하면, 옵티마이저는 소트 연산을 생략하고 `Sort Group By Nosort` 오퍼레이션으로 처리함.

**효율적인 처리 예시**

```sql
-- region이 선두 컬럼인 인덱스가 있는 경우
SELECT region, AVG(age), COUNT(*)
  FROM customer
 GROUP BY region;

-- 실행계획: Sort Group By Nosort
-- 인덱스 스캔 순서대로 region별 그룹핑이 자동으로 이뤄짐
```

**인덱스 구성 원칙**

- GROUP BY 절의 첫 번째 컬럼이 인덱스의 선두 컬럼이어야 함
- GROUP BY 절에 명시된 컬럼 순서와 인덱스 컬럼 순서가 일치해야 함
- WHERE 절 조건도 함께 고려하여 복합 인덱스 구성

**성능 효과**
region이 선두 컬럼인 인덱스를 이용하면, Sort Group By 연산을 생략할 수 있어 Sort Group By Nosort로 표시됨. 이는 대용량 데이터에서 그룹핑 작업 시 소트 부하를 완전히 제거하여 극적인 성능 향상을 가져다줌.
