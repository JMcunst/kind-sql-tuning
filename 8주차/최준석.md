## 5.3 인덱스를 이용한 소트 연산 생략

### 핵심 개념 정리

**인덱스를 활용한 소트 제거의 중요성**
인덱스는 항상 키 컬럼 순으로 정렬된 상태를 유지하므로, 이를 이용해 `ORDER BY` 절에서 발생하는 소트 오퍼레이션을 생략할 수 있음. 이는 특히 부분범위 처리 상황에서 극적인 성능 개선을 가져다줌.

**소트 생략을 위한 조건**
ORDER BY 절의 정렬 순서와 인덱스의 구성 순서가 일치해야 함. 즉, 쿼리에서 요구하는 정렬 방식이 인덱스가 이미 제공하는 정렬 상태와 동일해야 소트 연산을 생략할 수 있음.

## 5.3.1 Sort Order By 생략

### Sort Order By 생략 원리

**기본 원리**
ORDER BY 절에 사용된 컬럼들이 인덱스의 선두 컬럼부터 순서대로 구성되어 있으면, 옵티마이저는 `SORT (ORDER BY)` 오퍼레이션을 생략하고 인덱스 스캔만으로 정렬된 결과를 반환함.

**효과적인 인덱스 구성**

```sql
-- AS-IS: 소트 연산이 발생하는 경우
-- [거래일시] 인덱스만 존재할 때
SELECT 거래일시, 체결건수, 체결수량, 거래대금
  FROM 종목거래
 WHERE 종목코드 = 'KR123456'
 ORDER BY 거래일시;
-- 실행계획: TABLE ACCESS (FULL) → SORT (ORDER BY)

-- TO-BE: 소트 연산을 생략하는 경우
-- [종목코드 + 거래일시] 인덱스 구성
-- 실행계획: INDEX (RANGE SCAN) → TABLE ACCESS (BY INDEX ROWID)
```

**튜닝 포인트**

- WHERE 절의 조건 컬럼과 ORDER BY 절의 정렬 컬럼을 함께 고려하여 인덱스를 구성해야 함
- 인덱스 선두 컬럼부터 ORDER BY 절에 명시된 순서와 일치해야 함
- 내림차순(DESC) 정렬도 인덱스를 활용할 수 있음 (인덱스를 역순으로 스캔)

### 부분범위 처리와의 관계

**부분범위 처리의 정의**
쿼리 수행 결과 중 앞쪽 일부를 우선 전송하고 멈췄다가, 클라이언트가 추가 전송을 요청(Fetch Call)할 때마다 남은 데이터를 조금씩 나누어 전송하는 방식임.

**3-Tier 환경에서의 제약**
서버 리소스를 수많은 클라이언트가 공유하는 구조이므로 클라이언트가 특정 DB 커넥션을 독점할 수 없음. 단위 작업을 마치면 DB 커넥션을 커넥션 풀에 반환해야 하므로 쿼리 조회 결과를 클라이언트에게 '모두' 전송하고 커서(Cursor)를 닫아야 함.

**페이징 처리에서의 활용**
3-Tier 환경에서는 페이징 처리 기법을 통해 부분범위 처리의 이점을 활용함. 적절한 인덱스 구성으로 소트 연산을 생략하면 페이징 처리에서도 우수한 성능을 얻을 수 있음.

## 5.3.2 Top N 쿼리

### Top N 쿼리의 정의

전체 결과집합 중 상위 N개 레코드만 선택하는 쿼리임. DBMS별로 다른 문법을 제공함.

**DBMS별 Top N 쿼리 문법**

```sql
-- SQL Server
SELECT TOP 10 거래일시, 체결건수, 체결수량, 거래대금
  FROM 종목거래
 WHERE 종목코드 = 'KR123456'
   AND 거래일시 >= '20180304'
 ORDER BY 거래일시;

-- PostgreSQL/DB2
SELECT 거래일시, 체결건수, 체결수량, 거래대금
  FROM 종목거래
 WHERE 종목코드 = 'KR123456'
   AND 거래일시 >= '20180304'
 ORDER BY 거래일시
FETCH FIRST 10 ROWS ONLY;

-- Oracle
SELECT *
  FROM (SELECT 거래일시, 체결건수, 체결수량, 거래대금
          FROM 종목거래
         WHERE 종목코드 = 'KR123456'
           AND 거래일시 >= '20180304'
         ORDER BY 거래일시)
 WHERE ROWNUM <= 10;
```

### Top N 소트 알고리즘

**COUNT(STOPKEY) 오퍼레이션**
조건절에 부합하는 레코드가 아무리 많아도 그 중 ROWNUM으로 지정한 건수만큼 결과 레코드를 얻으면 거기서 바로 멈춘다는 뜻임.

**인덱스를 활용한 Top N 쿼리의 효율성**

- **소트 연산 생략**: [종목코드 + 거래일시] 인덱스가 있으면 `SORT (ORDER BY)` 오퍼레이션이 완전히 생략됨
- **조기 종료**: 인덱스를 스캔하다가 10개 레코드를 읽는 순간 바로 멈춤
- **부분범위 처리**: 전체 레코드를 읽을 필요가 없으므로 부분범위 처리 상황에서 매우 중요한 성능 이점을 제공함

**인덱스가 없는 경우의 처리**
인덱스로 소트 연산을 생략할 수 없어 Table Full Scan 방식일 때는 `SORT ORDER BY STOPKEY`를 사용함. Top N 소트 알고리즘이 작동하여 전체 데이터를 모두 정렬하지 않고 상위 N개만 유지하면서 정렬하므로 소트 부하를 최소화할 수 있음.

### 페이징 처리 최적화

**페이징 처리용 표준 패턴**

```sql
-- 3-Tier 환경에서 페이징 처리 표준 패턴
SELECT *
  FROM (SELECT ROWNUM NO, A.*
          FROM (SELECT 거래일시, 체결건수, 체결수량, 거래대금
                  FROM 종목거래
                 WHERE 종목코드 = 'KR123456'
                   AND 거래일시 >= '20180304'
                 ORDER BY 거래일시) A
         WHERE ROWNUM <= (:page * 10))
 WHERE NO >= (:page-1) * 10 + 1;
```

**페이징 처리 최적화 조건**

1. 인덱스 사용 가능하도록 조건절 구성
2. 조인은 NL 조인 위주로 처리 (룩업을 위한 작은 테이블을 해시 조인 Build Input으로 처리해도 됨)
3. ORDER BY 절이 있어도 소트 연산을 생략할 수 있도록 인덱스 구성

## 5.3.3 최솟값/최댓값 구하기

### 일반적인 MIN/MAX 처리 방식

**Sort Aggregate 오퍼레이션**
최솟값(MIN), 최댓값(MAX)을 구하는 SQL 실행계획에서 `Sort Aggregate` 오퍼레이션이 나타남. Sort Aggregate는 전체 데이터를 정렬하지는 않지만, 전체 데이터를 읽으면서 값을 비교하는 방식임.

```sql
-- 비효율적인 MIN/MAX 처리
SELECT MAX(SAL) FROM EMP;

-- 실행계획
0 SELECT STATEMENT Optimizer=ALL_ROWS
1 0 SORT (AGGREGATE)
2 1 TABLE ACCESS (FULL) OF 'EMP' (TABLE)
```

### 인덱스를 활용한 MIN/MAX 최적화

**인덱스 활용의 이점**
인덱스는 정렬되어 있으므로 전체 데이터를 읽지 않고 최솟값과 최댓값을 쉽게 찾을 수 있음.

**최적화된 처리 방식**

- **MIN 값 구하기**: 인덱스의 가장 왼쪽(첫 번째) 레코드 1개만 읽고 멈춤
- **MAX 값 구하기**: 인덱스의 가장 오른쪽(마지막) 레코드 1개만 읽고 멈춤

**튜닝 가이드**

1. MIN/MAX 함수에 사용되는 컬럼에 인덱스를 생성
2. 해당 컬럼이 복합 인덱스의 일부라면, 가능한 한 선두 컬럼에 위치시키거나 조건절과 함께 고려하여 인덱스 구성
3. 윈도우 함수 중 `RANK`, `ROW_NUMBER` 함수는 `MAX` 함수보다 소트 부하가 적으므로 상황에 따라 활용 고려

**성능 비교**
인덱스를 활용하면 수십만 건의 데이터에서 MIN/MAX를 구할 때도 1~2개 블록만 읽으면 되므로, Table Full Scan 방식 대비 수천 배의 성능 향상을 기대할 수 있음.

## 5.3.4 이력 조회

### 이력 테이블의 특성

**이력 테이블의 정의**
시간의 흐름에 따라 데이터의 변화를 추적하기 위해 과거 데이터를 모두 보관하는 테이블임. 일반적으로 [기본키 + 변경일시] 형태의 복합 인덱스를 가짐.

**일반적인 이력 조회 패턴**

1. **최근 이력 조회**: 각 항목별로 가장 최근의 이력 데이터를 조회
2. **특정 시점 이력 조회**: 특정 시점(기준일시) 현재 유효했던 이력 데이터를 조회
3. **기간별 이력 조회**: 특정 기간 동안의 모든 이력 변화를 조회

### 최근 이력 조회 최적화

**비효율적인 방법**

```sql
-- 서브쿼리를 이용한 방법 (비효율적)
SELECT *
  FROM 상품이력 A
 WHERE 변경일시 = (SELECT MAX(변경일시)
                   FROM 상품이력 B
                  WHERE B.상품코드 = A.상품코드);
```

**효율적인 방법: 윈도우 함수 활용**

```sql
-- 윈도우 함수를 이용한 방법 (효율적)
SELECT *
  FROM (SELECT 상품코드, 상품명, 가격, 변경일시,
               ROW_NUMBER() OVER (PARTITION BY 상품코드 ORDER BY 변경일시 DESC) RN
          FROM 상품이력)
 WHERE RN = 1;
```

**최적 인덱스 구성**
[상품코드 + 변경일시 DESC] 인덱스를 구성하면 각 상품별로 최근 데이터부터 정렬된 상태로 저장되어 ROW_NUMBER() 함수의 소트 부하를 최소화할 수 있음.

### 특정 시점 이력 조회

**기준일시 이하 최대값 조회**

```sql
-- 2024-01-15 현재 유효한 상품 정보 조회
SELECT *
  FROM (SELECT 상품코드, 상품명, 가격, 변경일시,
               ROW_NUMBER() OVER (PARTITION BY 상품코드
                                  ORDER BY 변경일시 DESC) RN
          FROM 상품이력
         WHERE 변경일시 <= '2024-01-15')
 WHERE RN = 1;
```

**튜닝 포인트**
[상품코드 + 변경일시] 인덱스가 있으면 각 상품별로 조건을 만족하는 첫 번째 레코드만 읽고 바로 다음 상품으로 이동할 수 있어 매우 효율적임.

## 5.3.5 Sort Group By 생략

### Group By 연산의 기본 처리 방식

**Sort Group By 연산**
일반적으로 GROUP BY 절이 있는 쿼리는 먼저 GROUP BY 컬럼을 기준으로 데이터를 정렬한 후, 정렬된 순서대로 그룹핑을 수행함. 이때 `Sort Group By` 오퍼레이션이 실행계획에 나타남.

### 인덱스를 활용한 Group By 최적화

**Sort Group By 생략 조건**
GROUP BY 절에 사용된 컬럼이 인덱스의 선두 컬럼과 순서까지 일치하면, 옵티마이저는 소트 연산을 생략하고 `Sort Group By Nosort` 오퍼레이션으로 처리함.

**효율적인 처리 예시**

```sql
-- region이 선두 컬럼인 인덱스가 있는 경우
SELECT region, AVG(age), COUNT(*)
  FROM customer
 GROUP BY region;

-- 실행계획: Sort Group By Nosort
-- 인덱스 스캔 순서대로 region별 그룹핑이 자동으로 이뤄짐
```

**인덱스 구성 원칙**

- GROUP BY 절의 첫 번째 컬럼이 인덱스의 선두 컬럼이어야 함
- GROUP BY 절에 명시된 컬럼 순서와 인덱스 컬럼 순서가 일치해야 함
- WHERE 절 조건도 함께 고려하여 복합 인덱스 구성

**성능 효과**
region이 선두 컬럼인 인덱스를 이용하면, Sort Group By 연산을 생략할 수 있어 Sort Group By Nosort로 표시됨. 이는 대용량 데이터에서 그룹핑 작업 시 소트 부하를 완전히 제거하여 극적인 성능 향상을 가져다줌.
