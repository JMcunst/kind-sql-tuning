# 4.3 해시 조인 (Hash Join)

해시 조인은 대량의 데이터셋을 빠르게 조인할 수 있는 기법으로, 특히 인덱스가 없거나 사용할 수 없는 경우에 매우 유용합니다. NL 조인과 소트 머지 조인의 단점을 보완하며, 대규모 배치 처리나 DW 환경에서 자주 사용됩니다.

이 문서에서는 해시 조인의 작동 원리, 빠른 이유, 튜닝 포인트를 실무 중심으로 정리합니다.

---

## 4.3.1 기본 메커니즘

해시 조인은 **Build-Input**과 **Probe-Input**으로 나누어 작동합니다.

1. **Build 단계**

   * 조인 대상 중 작은 테이블 또는 서브쿼리 결과를 메모리에 올림
   * 조인 키 기준으로 해시 테이블 생성

2. **Probe 단계**

   * 큰 테이블을 스캔하면서 해시 테이블에서 매칭되는 키를 찾아 조인 수행

### 예시

```sql
SELECT *
FROM large_table l
JOIN small_table s ON l.id = s.id;
```

* `small_table` → Build Input
* `large_table` → Probe Input

---

## 4.3.2 해시 조인이 빠른 이유

* 해시 기반 검색은 O(1)에 가까운 성능을 제공 → 탐색 속도가 매우 빠름
* 소트 연산이 필요 없음 → 디스크 I/O 감소
* 조인 키에 인덱스가 없어도 빠르게 동작 가능

💡 특히 **인덱스를 이용할 수 없는 조건**에서 해시 조인은 압도적인 성능을 발휘함

---

## 4.3.3 대용량 Build Input 처리

Build Input이 메모리에 올릴 수 없을 정도로 크면 다음과 같은 처리가 발생합니다:

1. Build Input을 여러 블록으로 나눔
2. 각 블록마다 해시 테이블을 만들고 디스크에 저장
3. Probe Input도 동일 해시 분할 방식으로 나누어 매칭 수행

📌 이 과정을 **Grace Hash Join**이라고 하며, 디스크 I/O 비용이 증가함

### 실무 팁

* Build Input은 **충분히 작은 집합**이 되도록 SQL 튜닝 필요
* `WHERE`, `JOIN`, `EXISTS` 등을 활용해 미리 필터링

---

## 4.3.4 해시 조인 실행계획 제어

옵티마이저는 기본적으로 통계 정보를 기반으로 조인 방식을 선택합니다. 하지만 아래 방법으로 해시 조인을 유도하거나 회피할 수 있습니다.

### Oracle

```sql
/*+ USE_HASH(s) */
```

### PostgreSQL

```sql
SET enable_hashjoin = off;
-- 또는 ON으로 설정하여 유도 가능
```

### 실무 팁

* 해시 조인은 메모리를 많이 사용하므로, **작은 테이블이 Build Input이 되도록 순서 조정**
* 힌트를 사용할 때는 신중히! 통계 정보가 부정확하면 성능 악화 가능

---

## 4.3.5 조인 메소드 선택 기준

| 조건             | 적합한 조인 방식        |
| -------------- | ---------------- |
| 인덱스 존재, 소량 데이터 | Nested Loop Join |
| 정렬된 데이터, 중간 크기 | Sort Merge Join  |
| 인덱스 없음, 대용량    | Hash Join        |

### 실무 기준 요약

* 해시 조인은 **대량 데이터** + **인덱스 없음**일 때 기본 선택지
* OLTP보다는 OLAP 또는 일괄 처리 배치 쿼리에 적합

---

# 4.4 서브쿼리 조인 (Subquery Join)

서브쿼리는 SQL에서 흔히 사용되는 문법이지만, 옵티마이저가 이를 어떻게 처리하느냐에 따라 **실행 성능에 큰 차이**가 발생합니다. 특히 서브쿼리를 조인 형태로 변환하거나 반대로 조인 대신 서브쿼리를 쓰는 선택은 쿼리 튜닝에서 중요한 고려 요소입니다.

이 문서에서는 서브쿼리와 조인의 관계, 변환이 필요한 이유, 스칼라 서브쿼리의 주의점 등을 중심으로 정리합니다.

---

## 4.4.1 서브쿼리 변환이 필요한 이유

서브쿼리는 보기에는 간결하지만, **실행 계획상 비효율적**일 수 있습니다. 특히 다음과 같은 문제가 발생할 수 있습니다:

* 상관 서브쿼리로 인해 **N회 반복 실행** (Nested Loop 형태)
* 서브쿼리 결과에 인덱스를 활용하지 못함
* 옵티마이저가 서브쿼리를 조인으로 변환하지 못하는 경우 비효율 발생

### 실무 팁

* 서브쿼리는 조인으로 변환하는 것이 일반적으로 더 빠름
* 반복 실행이 우려되면 명시적인 조인으로 바꾸는 것을 고려

---

## 4.4.2 서브쿼리와 조인

비상관 서브쿼리는 `JOIN`으로 쉽게 변환할 수 있습니다. 성능 측면에서 이득이 크며, 실행계획에서도 병렬 처리나 해시 조인을 유도할 수 있습니다.

### 예시

```sql
-- 서브쿼리 방식
SELECT *
FROM orders o
WHERE o.customer_id IN (
  SELECT c.id FROM customers c WHERE c.status = 'VIP'
);

-- 조인 방식
SELECT o.*
FROM orders o
JOIN customers c ON o.customer_id = c.id
WHERE c.status = 'VIP';
```

### 비교

| 방식   | 성능      | 인덱스 활용 | 병렬 처리 |
| ---- | ------- | ------ | ----- |
| 서브쿼리 | 느릴 수 있음 | 제한적    | 제한적   |
| 조인   | 더 빠름    | 유리     | 가능    |

---

## 4.4.3 뷰(View)와 조인

뷰는 서브쿼리처럼 동작하며, 옵티마이저가 뷰 내부까지 파고들어 변환할 수 있는지를 기준으로 **MERGE 가능 여부**가 갈립니다.

### View Merge란?

* 뷰 내부 쿼리를 외부 쿼리와 통합해 하나의 실행계획으로 만드는 최적화
* View Merge가 안 되면 뷰는 별도 서브쿼리로 처리되어 비효율 발생 가능

### 실무 팁

* 성능이 중요한 뷰는 복잡한 집계 또는 조인을 피하고 MERGE 가능하게 설계
* `WITH` 구문(Common Table Expression, CTE)도 같은 원리 적용

---

## 4.4.4 스칼라 서브쿼리 조인

스칼라 서브쿼리는 **SELECT 절에 존재**하며, 각 행마다 1개의 값을 반환하는 서브쿼리입니다.

### 예시

```sql
SELECT o.id,
       (SELECT COUNT(*) FROM order_items i WHERE i.order_id = o.id) AS item_count
FROM orders o;
```

이 방식은 `orders` 테이블의 행 수만큼 `order_items`에 대해 COUNT 쿼리를 반복 수행하게 되므로 성능에 큰 영향을 줍니다.

### 대안: OUTER JOIN + GROUP BY

```sql
SELECT o.id, COUNT(i.id) AS item_count
FROM orders o
LEFT JOIN order_items i ON o.id = i.order_id
GROUP BY o.id;
```

### 실무 팁

* 스칼라 서브쿼리는 직관적이지만 성능 이슈가 자주 발생
* 조인 + GROUP BY 방식이 훨씬 효율적인 경우가 많음
