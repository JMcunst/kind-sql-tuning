# 6.2 Direct Path I/O 활용

## 핵심 개념 정리

**Direct Path I/O의 중요성**

Direct Path I/O는 오라클 DB Buffer Cache를 경유하지 않고 곧바로 데이터 블록을 읽고 쓸 수 있도록 제공되는 기능으로, 대량 데이터 처리 시 성능을 크게 향상시킬 수 있음. Conventional Path I/O : DB Buffer Cache를 경유하는 일반적인 I/O 작업과 대비되는 개념.

**Direct Path I/O 활용 방법**

1. Direct Path Read/Write Temp 활용
2. Direct Path Insert 방식 적용
3. 병렬 DML 처리
4. 대량 데이터 처리 시 버퍼 캐시 경유 회피

## 6.2.1 Direct Path I/O

### Direct Path I/O가 작동하는 경우

**1. Direct Path Read/Write Temp**

대량의 데이터 정렬 시 PGA의 Sort Area가 부족할 경우 Temp 테이블 스페이스 이용→ Sort Area에 정렬된 데이터를 Temp 테이블 스페이스에 쓰고 이를 다시 읽을 때 Direct Path I/O 발생

**2. Direct Path Read**

병렬 쿼리로 Full Scan 수행 시 Direct Path Read 발생. 병렬도를 2로 주고 병렬쿼리 수행 시 성능 향상 효과를 얻을 수 있음.

**Direct Path I/O의 특징**

- 버퍼 캐시를 경유하지 않아 대량 데이터 처리 시 효율적
- 시스템 전반의 I/O 성능 향상하지만 개별 프로세스입장에서는 좋지 않을 수 있음
- 대량 데이터 읽기/쓰기 시 버퍼 캐시 탐색 오버헤드 제거

## 6.2.2 Direct Path Insert

### 기본 메커니즘

**일반적인 INSERT 방식의 문제점**

데이터 입력시 빈 공간을 가진 블록리스트를 관리하는 Freelist로 부터 블록을 할당받아 무작위로 값을 입력. Freelist에서 할당받은 블록을 버퍼 캐시에서 찾아보고, 없으면 데이터 파일에서 읽어 캐시에 적재한 후 데이터를 삽입하므로 대량 데이터 입력시 비효율적임.

**Direct Path Insert의 장점**

Freelist를 거치지 않고 HWM 바깥 영역에, 그것도 버퍼 캐시를 거치지 않고 데이터 파일에 곧바로 입력하는 방식

- Undo 데이터를 쌓지 않음 (커밋할 때만 HWM 상향 조정)
- 버퍼 캐시 경유 없이 직접 데이터 파일에 입력
- nologging 모드에서 Redo 로그 최소화로 더 빠른 처리

**Direct Path Insert 사용 방법**

```sql
-- 1. APPEND 힌트 사용
INSERT /*+ APPEND */ INTO target_table SELECT * FROM source_table;

-- 2. CTAS (Create Table As Select) 사용
CREATE TABLE new_table AS SELECT * FROM source_table;

-- 3. SQL*Loader의 direct path 모드
```

**주의사항**

Direct Path Insert 방식으로 데이터를 입력하면 Exclusive 모드 테이블 Lock이 걸려 작업이 수행되는 동안 다른 트랜잭션은 해당 테이블에 DML을 수행하지 못하게 됨

nologging 상태에서 입력한 데이터는 장애가 발생했을 때 복구가 불가능하므로 INSERT 후 바로 백업 실시하거나 언제든 재생 가능한 데이터를 INSERT할 때만 사용해야 함.

## 6.2.3 병렬 DML

### 병렬 DML 활용 방법

**세션 설정**

```sql
-- 병렬 DML 활성화
ALTER SESSION ENABLE PARALLEL DML;

-- 병렬 처리를 위한 메모리 설정
ALTER SESSION SET HASH_AREA_SIZE = 1024000000;
ALTER SESSION SET SORT_AREA_SIZE = 2147483647;
ALTER SESSION SET SORT_AREA_RETAINED_SIZE = 2147483647;
ALTER SESSION SET WORKAREA_SIZE_POLICY = MANUAL;
```

**병렬 DML 예제**

INSERT INTO SELECT 문장은 PARALLEL 힌트의 위치에 따라 어느 부분을 병렬화 할 것인지 지정할 수 있다. SELECT 뒤에만 힌트를 주면 SELECT하는 부분만 병렬화되고 INSERT 뒤에만 힌트를 주면 실제 INSERT하는 작업만 병렬화하게 됨

```sql
-- INSERT와 SELECT 모두 병렬화
INSERT /*+ PARALLEL(3) */ INTO target_table
SELECT /*+ PARALLEL(3) */ * FROM source_table;
```

**병렬 DML 제약사항**

병렬 DML 수행시 Exculsive 모드 테이블 Lock이 걸리므로 업무 트랜잭션이 발생하는 주간에는 삼가해야 함

병렬 DML을 수행한 트랜잭션에서는 병렬 DML로 수정한 테이블에 어떠한 접근도 할 수 없으며, 같은 트랜잭션 내에서 수정한 테이블에 대해 병렬 DML로 접근하려 할 경우에도 병렬 DML을 수행할 수 없음

**튜닝 가이드**

1. 대량 데이터 처리 시 병렬 DML 적극 활용
2. 트랜잭션이 빈번한 시간대에는 사용 금지
3. 작업 완료 후 parallel 옵션을 noparallel로 변경
4. 부분범위처리 방식 조회 시 필요한 만큼 Fetch 후 커서 즉시 닫기

# 6.3 파티션을 활용한 DML 튜닝

## 핵심 개념 정리

**파티션 활용의 중요성**

파티션을 활용하면 대량 추가/변경/삭제 작업을 빠르게 처리할 수 있음. 파티셔닝은 관리적 측면과 성능적 측면에서 모두 큰 이점을 제공함.

**파티션 튜닝의 핵심 원리**

1. 파티션 Pruning을 통한 액세스 범위 최소화
2. 파티션 단위 DML 작업으로 성능 향상
3. 인덱스 파티션 전략을 통한 관리 효율성 증대
4. 파티션 교체 방식을 통한 대량 DML 최적화

## 6.3.1 테이블 파티션

### 파티셔닝 기본 개념

**파티셔닝의 정의**

파티셔닝(Partitioning) : 테이블 또는 인덱스 데이터를 특정 컬럼(파티션 키) 값에 따라 별도 세그먼트에 나눠서 저장

**파티션이 필요한 이유**

관리적 측면 : 파티션 단위 백업, 추가, 삭제, 변경 -> 가용성 향상

성능적 측면 : 파티션 단위 조회 및 DML, 경합 또는 부하 분산

### 파티션 유형

**1. Range 파티션**

가장 기초적인 방식으로 날짜 컬럼을 기준으로 파티셔닝

- 주문일자 기준으로 분기별 Range 파티셔닝 가능
- 검색조건을 만족하는 파티션만 골라 읽어 이력성 데이터를 Full Scan 방식으로 조회 시 성능 크게 향상
- 보관주기 정책에 따라 과거데이터 파티션만 백업, 삭제하는 등 데이터 관리가 효율적이고 빠름

**2. Hash 파티션**

파티션 키 값을 해시 함수에 입력해서 반환받은 값이 같은 데이터를 세그먼트에 저장하는 방식

- 파티션 개수만 사용자가 결정, 데이터 분산 알고리즘은 오라클 내부 해시함수가 결정
- 고객ID처럼 변별력이 좋고 데이터 분포가 고른 컬럼을 파티션 기준으로 선정해야 효과적
- 해시 알고리즘 특성상 등치(=) 조건 또는 IN-List 조건으로 검색시 파티션 Pruning 작동

**3. List 파티션**

사용자가 정의한 그룹핑 기준으로 데이터를 분할 저장하는 방식

- 순서가 아닌 불연속적인 값의 목록으로 파티션 결정
- 가능하면 각 파티션에 값이 고르게 분산되도록 해야 함

### 파티션 Pruning

**Pruning의 개념**

파티션 Pruning : Prune 은 불필요한 부분을 제거한다는 의미

파티션 테이블에 대한 SQL 성능 향상 원리는 파티션 Pruning 이다.(읽지 않아도 되는 파티션 세그먼트는 액세스 대상에서 제외)

**성능 향상 효과**

- Full Scan 하더라도 전체가 아닌 일부 파티션 세그먼트만 조회
- 파티션과 병렬처리가 만나면 효과가 증진

## 6.3.2 인덱스 파티션

### 인덱스 파티션 유형

**구분 기준**

테이블 파티션과 인덱스 파티션은 구분해야 함

파티션 인덱스는 각 파티션이 커버하는 테이블 파티션 범위에 따라 로컬과 글로벌로 나뉨

**1. 로컬 파티션 인덱스 (Local Partitioned Index)**

각 테이블 파티션과 인덱스 파티션이 서로 1:1 대응 -> 오라클이 자동으로 파티션 인덱스 관리

**로컬 파티션 인덱스의 장점**

- 인덱스 파티션은 테이블 파티션 속성을 그대로 상속받음
- 1:1 대응 관계로 오라클이 자동 관리
- 테이블 파티션 구성 변경(add, drop, exchange) 하더라도 인덱스를 재생성할 필요가 없어 서비스 중단없이 작업 가능
- 관리 편의성이 매우 좋음

**2. 글로벌 파티션 인덱스 (Global Partitioned Index)**

로컬이 아닌경우 전부 글로벌이며 테이블 파티션과 인덱스 파티션이 독립적인 구성(파티션 키, 파티션 기준값 정의)을 가짐

**글로벌 파티션 인덱스의 단점**

- 테이블 파티션 구성을 변경(drop, exchange, split) 하는 순간 Unusable 상태로 바뀌므로 곧바로 인덱스 재생성해야 함
- 그동안 서비스 중단이 발생

**3. 비파티션 인덱스 (Non-Partitioned Index)**

- 인덱스를 파티셔닝하지 않은 것
- 글로벌 파티션 인덱스와 마찬가지로 테이블 파티션 구성 변경 시 서비스 중단

### 중요한 인덱스 파티션 제약

**Unique 인덱스 파티셔닝 제약조건**

"Unique 인덱스를 파티셔닝하려면 파티션 키가 모두 인덱스 구성 컬럼이어야 한다."

**제약조건의 이유**

Unique 인덱스를 파티셔닝할 때 파티션 키가 인덱스 컬럼에 포함되어야 한다는 조건은 DML 성능 보장을 위해 당연히 있어야 할 제약조건

- 파티션 키와 PK 인덱스 키가 다르면 중복값 확인을 위해 모든 인덱스 파티션을 탐색해야 함
- 추가로 Lock 메커니즘이 적용되어 성능 저하 발생

**설계 권장사항**

서비스 중단 없이 파티션 구조를 빠르게 변경하려면, PK 를 포함한 모든 인덱스가 로컬 파티션 인덱스이어야 함

가급적 인덱스를 로컬 파티션으로 구성해야 하고 그러기 위해 테이블 설계 시 PK 를 잘 구성해야 함

## 6.3.3 파티션을 활용한 대량 UPDATE 튜닝

### 대량 UPDATE의 문제점

**인덱스 재생성 vs 유지 판단 기준**

입력/수정/삭제하는 데이터 비중이 5% 가 넘으면 인덱스를 활용하기 보다는 인덱스 없이 작업한 후 재생성하는게 더 빠름

예를 들어 10억건의 데이터가 있고 수정 비율이 5%가 넘으면, 데이터 수정시 인덱스를 Drop 하고 재생성하기 부담이 되어 인덱스를 그대로 두고 작업하는 경우가 많음

### 파티션 교체 방식 UPDATE

**파티션 교체 방식의 절차**

테이블이 파티셔닝 되있고, 인덱스가 로컬 파티션인 경우 수정된 값을 갖는 임시 세그먼트를 만들어 원본 파티션과 바꿔치기하는 방식

1. **임시 테이블 생성**
2. **데이터를 읽어 임시 테이블에 입력하면서 데이터 수정**
3. **임시 테이블에 원본 테이블과 같은 구조로 인덱스 생성**
4. **파티션과 임시 테이블 교체**
5. **임시 테이블 drop**

**장점**

- 대량 UPDATE 시 인덱스 유지 비용 최소화
- 서비스 중단 시간 단축
- 로컬 파티션 인덱스 활용으로 인덱스 재생성 부담 감소

## 6.3.4 파티션을 활용한 대량 DELETE 튜닝

### DELETE가 느린 이유

**DELETE 작업의 복잡성**

삭제하면서 인덱스 관리는 시간 소요가 큼

**DELETE 작업 단계**

왜 DELETE 가 느린가?

1. 테이블 레코드 삭제
2. 테이블 레코드 삭제에 대한 Undo Logging
3. 테이블 레코드 삭제에 대한 Redo Logging
4. 인덱스 레코드 삭제
5. 인덱스 레코드 삭제에 대한 Undo Logging
6. 인덱스 레코드 삭제에 대한 Redo Logging
7. Undo(2,5)에 대한 Redo Logging

### 파티션을 활용한 DELETE 최적화

**백업 후 재입력 방식**

대량 데이터를 지울 때는 남길 데이터만 백업했다가 재입력하는 방식이 빠름

**최적화 절차**

임시 테이블 생성, 남길 데이터만 복제
삭제 대상 테이블 파티션 Truncate
임시 테이블에 복제해둔 데이터를 원본 테이블에 입력
임시 테이블 drop

**서비스 중단없이 파티션 Drop/Truncate 조건**

서비스 중단없이 파티션을 Drop 또는 Truncate 하기위한 조건

1. 파티션키와 커팅 기준 컬럼이 일치
2. 파티션 단위와 커팅 주기가 일치
3. 모든 인덱스가 로컬 파티션 인덱스

## 6.3.5 파티션을 활용한 대량 INSERT 튜닝

### 인덱스 재생성 전략

**일반적인 대량 INSERT 최적화**

대량 데이터를 INSERT 하는 경우 인덱스를 Unusable 시켰다가 재생성하는 방식이 더 빠를 수 있음

**일반 테이블 INSERT 절차**

인덱스 Unusable 상태로 전환
(가능하면 Direct Path Insert) 대량 데이터 입력
인덱스 재생성

### 파티션 테이블에서의 INSERT 최적화

**파티션 테이블의 특수성**

초대용량 인덱스 재생성 부담이 크므로, 인덱스를 그대로 둔(Unusable로 전환하지 않은) 상태로 INSERT 함. 하지만 테이블 파티셔닝이 되있고, 인덱스도 로컬 파티션이라면 파티션 단위로 인덱스 재생성이 가능하므로 부담이 적음

**파티션 테이블 INSERT 절차**

작업 대상 테이블 파티션과 매칭되는 인덱스 파티션을 Unusable 상태로 전환
(가능하면 Direct Path Insert) 대량 데이터 입력
인덱스 파티션 재생성

**튜닝 가이드**

1. 파티션 단위 인덱스 재생성으로 부담 최소화
2. Direct Path Insert와 병행하여 최대 성능 확보
3. 로컬 파티션 인덱스 구성으로 관리 편의성 증대
4. 작업 대상 파티션만 선별적으로 처리하여 영향 범위 최소화
