# 2장
## 인덱스
- 큰 테이블에서 소량의 데이터를 검색할 때 사용 
- 인덱스 튜닝의 핵심 
  - 인덱스 스캔 과정에서 발생하는 비효율 줄이기
  - 테이블 액세스 횟수 줄이기
    - 인덱스 스캔 후 테이블 레코드를 액세스할 때 랜덤 I/O 방식을 사용하므로 이를 '랜덤 액세스 최소화 튜닝' 이라고 한다.

## SOL 튜닝은 랜덤 I/O 와의 전쟁
- 데이터베이스 성능이 느린 이유는 디스크 I/O 때문
  - 특히 랜덤 I/O

## 인덱스 구조
- B-TREE
- 루트 - 브랜치 - 리프 
- 리프 블록에 저장된 각 레코드는 ROWID를 갖는다
  - 데이터 블록 주소 + 로우 번호

## 인택스 탐색 과정
- 수직적 탐색
  - 인덱스 스캔 시작 지점을 찾는 과정
    - 조건을 만족하는 첫 번째 레코드를 찾는 과정
- 수평적 탐색 
  - 데이터를 찾는 과정
    - 인덱스를 수평적으로 탐색하는 이유는?
      - 1. 조건절을 만족하는 데이터를 모두 찾기 위해
      - 2. ROWID를 얻기 위함(커버링 인덱스의 경우 인덱스만 스캔하지만 일반적으로 테이블도 액세스해야하는데 이때 ROWID가 필요하다. )

  
# 1장 
## sql 최적화 과정 
- 파싱 by sql parser
  - 파싱 트리 생성
  - syntax 체크
  - semantic 체크 
- 최적화 by optimizer
- 로우 소스 생성

## 옵티마이저가 SQL을 최적화할 때 발생하는 일
- 다섯 개의 테이블 조인하는 경우 
  - 조인 순서만 고려해도 120가지(5!)
  - 그런데 조인 순서 뿐만 아니라 다양한 조인 방식이 있음 (NL, 소트 머지, 해시 조인 등)
- 그리고 테이블을 전체 스캔할지, 인덱스를 이용할지 결정해야 함
- 인덱스 스캔에도 Index Range, Index Unique, Index full Scan 등 다양한 방식
- 게다가 인덱스는 테이블 당 하나가 아님

## 라이브러리 캐시가 필요한 이유
- 우선 라이브러리 캐시는 system global area(SGA)의 구성 요소
  - 서버 프로세스와 백그라운드 프로세스가 공통으로 액세하는 데이터와 제어 구조를 캐싱하는 메모리 공간
    - **디스크에서 읽어온 데이터를 저장하는 메모리 영역**
- 그리고 라이브러리 캐시가 필요한 이유를 이해하려면 소프트파싱과 하드파싱을 알아야 한다. 
  - 소프트 파싱: DBMS에 의해 sql 파싱 -> 캐시 존재 유무 확인 -> 있으면 바로 실행 단계로 넘어감 
  - 하드 파싱: 캐시 존재 유무 찾기 실패 -> 최적화 -> 로우 소스 생성
- 데이터베이스 처리 과정은 대부분 I/O 작업에 대부분 집중되지만 하드 파싱은 CPU를 많이 씀
- 하드 파싱을 통해 생성한 내부 프로시저를 한번만 쓰고 버리면? 비효율적임. 그래서 라이브러리 캐시가 필요하다.
- 비교
  - 라이브러리 캐시: SQL, 실행 계획, 함수/프로시저 등을 저장하면 '코드 캐시'
  - DB 버퍼 캐시: 디스크에서 어렵게 읽은 데이터 블록을 캐싱
    - 같은 블록에 대한 반복적인 I/O Call을 줄이는 목적


## SQL이 느린 이유
- 디스크 I/O 때문(비효율적인 쿼리, 인덱스를 사용하지 않거나 잘못 사용하는 경우, 네트워크 지연 등 다양한 이유가 있다)
- 디스크 I/O 떄문에 SQL이 느린 이유를 쿼리 실행 과정을 통해 이해해보자.
  - **쿼리 실행 과정**(프로세스는 CPU에 의해 생성, 실행)
    - 사용자에 의해 SQL 쿼리 실행 시 해당 쿼리는 DBMS에 의해 처리된다. 
    - 이 과정에서 쿼리 실행 담당 프로세스가 생성된다.  
    - 필요한 데이터가 메모리에 없으면 프로세스는 디스크에 I/O 요청을 보내고 DBMS 판단에 의해 해당 프로세스는 CPU를 운영체제에 반환하게 된다. 
      - 디스크 I/O 작업이 완료될 때까지 해당 프로세스는 대기 상태(sleep) 상태로 들어감
        - 대기 큐에 추가 됨
    - I/O 작업이 완료되면 DBMS는 해당 프로세스에 알림을 보내고 대기 상태에서 실행 가능한 상태로 전환된다. 
      - 그리고 CPU 재할당, 쿼리의 나머지 작업 수행

## 데이터베이스 저장 구조
- 테이블 스페이스: 데이터베이스 객체(테이블, 인덱스)가 저장되는 논리적 저장소
  - 세그먼트: 데이터베이스 객체를 저장하기 위한 물리적인 저장소(데이터, 인덱스, UNDO, TEMP 세그먼트)
    - 익스텐드: 블록 집합, 데이터를 저장하기 위해 할당된 연속적인 블록 집합
      - 블록: 데이터베이스의 가장 작은 단위, 디스크에서 데이터를 읽고 쓰는 기본 단위 

## 시퀀셜 액세스와 랜덤 액세스
- 시퀀셜: 논리적 또는 물리적으로 연결된 순서에 따라 차례대로 블록을 읽는 방식
  - 특정 조건에 맞는 데이터를 찾기 위해 모든 행을 읽는 풀테이블스캔은 시퀀셜 액세스를 사용한다. 
- 랜덤: 논리적, 물리적 순서를 따르지 않고 한 블록씩 접근하는 방식

## 논리적 I/O와 물리적 I/O
- 논리적 I/O
  - 메모리 상의 버퍼 캐시 경유
  - 전기적 신호
- 물리적 I/O
  - 버퍼 캐시 MISS
  - 디스크 I/O
  - 액세스 암을 통해 물리적 작용이 일어나기 때문에 메모리 I/O에 비해 봍오 10,000배 쯤 느림
- 논리적 I/O를 줄임으로써 물리적 I/O를 줄이는 것이 곧 SQL 튜닝이다. 
  - 논리적 I/O는 통제 가능한 변수지만 물리적 I/O는 통제 불가능(메모리 증설 후 DB 버퍼 캐시 크기를 늘리는 방법 외에)

## 인덱스를 이용하는데 왜 성능이 더 느릴까?
- table full scan
  - 시퀀셜 액세스, multi block I/O 방식
  - 한 블록에 속한 모든 레코드를 한번에 읽어 들이고, 캐시에서 못 찾으면 한 번의 수면(I/O CALL)을 통해 인접한 수십~수백 개의 블록을 한 꺼번에 I/O하는 메커니즘
  - 수십~수백 건의 소량 데이터를 찾을 때 수백만~수천만 건의 데이터를 스캔하는 건 비효율적이기 때문에 큰 테이블에서 소량 데이터를 검색할 때는 인덱스를 이용하는 게 좋다. 
- index range scan
  - 랜덤 액세스, single block I/O 방식
  - 캐시에서 블록을 못 찾으면 레코드 하나를 읽기 위해 매번 잠을 자는 I/O 메커니즘 
  - 따라서 많은 데이터를 읽을 때는 table full scan보다 불리하다. 
  - 게다가 읽었던 블록을 반복해서 읽는 비효율 존재
  - 한 블록에 평균 500개 레코드가 있다면 같은 블록을 최대 500번 읽는다. 각 블록을 단 한 번 읽는 table full scan보다 불리하다. 
