
## 1.1 SQL 파싱과 최적화

### 1.1.1 구조적, 집합적, 선언적 질의 언어

SQL(Structured Query Language)은 구조적이고, 집합적이며, 선언적인 질의 언어임.<br>
결과는 집합적으로 나오지만, 그 과정을 절차적으로 만들어내야 함.<br>
즉, 사용자는 원하는 결과만 적고, 그 결과를 얻는 절차는 DB가 알아서 짜줌.<br>
그 역할을 하는 게 옵티마이저임.<br>
SQL 옵티마이저 = 자동 프로그래머라고 보면 됨.

---

### 1.1.2 SQL 최적화

**SQL 최적화 과정**

* 파싱
  → SQL 문장을 파싱 트리로 변환
  → 문법(Syntax) 검사
  → 의미(Semantic) 검사 (존재하지 않는 테이블, 컬럼, 권한 등 체크)

* 최적화
  → 옵티마이저가 통계 정보 기반으로 다양한 실행 계획 비교 후 최적 선택

* 로우 소스 생성
  → 선택된 실행 계획을 실제 실행 가능한 코드(프로시저) 형태로 변환

---

### 1.1.3 SQL 옵티마이저

옵티마이저 = SQL을 가장 효율적으로 수행할 수 있도록 실행 계획을 만들어 주는 DBMS의 핵심 엔진.<br>
통계 정보 기반으로 실행 계획 후보를 만들고, 그 중에서 가장 비용 낮은 계획을 선택함.<br>

---

### 1.1.4 실행계획과 비용

실행 계획 = 옵티마이저가 생성한 처리 절차를 트리 구조로 표현한 것.<br>
유저는 이걸 보고 SQL이 어떻게 실행되는지 파악할 수 있음.<br>

---

### 1.1.5 옵티마이저 힌트

옵티마이저 힌트 = 옵티마이저가 아닌 사용자가 직접 실행 계획 경로를 지정할 수 있게 해주는 기능.<br>
옵티마이저의 선택이 비효율적일 때 수동 개입할 수 있음.<br>

---

## 1.2 SQL 공유 및 재사용

### 1.2.1 소프트 파싱 vs 하드 파싱

라이브러리 캐시 = SGA 내에 존재하며, SQL의 파싱/최적화 결과를 저장해두는 공간.<br>
소프트 파싱 = 동일한 SQL이 캐시에 존재할 때, 재사용하는 방식<br>
하드 파싱 = 처음 보거나 캐시에 없으면 파싱/최적화/로우 소스 생성을 다시 수행함

**왜 '하드' 파싱인가?**
→ 고려할 게 너무 많음 (조인 순서, 인덱스 유무, 통계, 시스템 파라미터 등)<br>
→ CPU 리소스 많이 씀<br>
→ 그래서 하드 파싱 결과는 재사용 가능한 형태로 저장해야 함

---

### 1.2.2 바인드 변수의 중요성

SQL은 이름이 없음.<br>
즉, 전체 텍스트 기준으로 캐시에 저장되므로 작은 차이(띄어쓰기, 대소문자)도 다른 SQL로 인식함.

**예시:**

```sql
SELECT * FROM CUSTOMER WHERE LOGIN_ID = 'oraking';
SELECT * FROM CUSTOMER WHERE LOGIN_ID = 'javaking';
```

→ 이 두 개는 다른 SQL로 처리됨 → 매번 하드 파싱 발생 → 성능 저하

**해결법:**

```sql
SELECT * FROM CUSTOMER WHERE LOGIN_ID = :login_id;
```

→ 바인드 변수를 쓰면 최초 1회만 하드 파싱하고 이후엔 소프트 파싱 가능<br>
→ 공유 가능한 SQL 구조가 됨

---

## 1.3 데이터 저장 구조 및 I/O 메커니즘

### 1.3.1 SQL이 느린 이유

대부분의 SQL이 느린 이유는 디스크 I/O 때문임.<br>
디스크 I/O는 프로세스가 대기 상태가 되므로 많을수록 성능 떨어짐.<br>
디스크 I/O 횟수 줄이는 게 튜닝의 핵심.

---

### 1.3.2 데이터베이스 저장 구조

* 블록 : DB의 최소 I/O 단위 (기본 8KB)
* 익스텐트 : 연속된 블록의 집합
* 세그먼트 : 테이블, 인덱스 같은 오브젝트의 저장 공간
* 테이블스페이스 : 세그먼트를 담는 논리적 단위
* 데이터파일 : 실제 디스크 파일

세그먼트 내 익스텐트는 서로 떨어질 수 있음 → 다중 파일로 분산 저장

---

### 1.3.3 블록 단위 I/O

DB는 항상 **블록 단위**로 데이터를 읽음.<br>
→ 레코드 1개만 필요해도 블록 전체를 메모리에 올림<br>
→ 인덱스도 마찬가지

---

### 1.3.4 시퀀셜 vs 랜덤 액세스

* **시퀀셜 액세스** : 연속된 블록을 순차적으로 읽음 (예: Full Table Scan)<br>
* **랜덤 액세스** : 필요한 블록만 개별적으로 읽음 (예: Index Scan)

익스텐트 맵을 통해 DBA 주소 확인 → 순차적으로 읽을 수 있음

---

### 1.3.5 논리적 I/O vs 물리적 I/O

* **논리적 I/O** : 메모리(DB 버퍼 캐시)에서 데이터를 읽음<br>
* **물리적 I/O** : 디스크에서 직접 데이터를 읽음 → 느림

**버퍼 캐시 히트율(BCHR):**

```math
BCHR = (1 - 물리적 I/O / 논리적 I/O) * 100
```

→ 평균 99% 이상이 이상적<br>
→ 논리적 I/O를 줄여서 물리적 I/O도 줄이는 게 튜닝 목표

---

### 1.3.6 Single Block I/O vs Multiblock I/O

* **Single Block I/O** : 한 번에 한 블록 읽음 (인덱스에서 주로 사용)<br>
* **Multiblock I/O** : 한 번에 여러 블록 읽음 (Full Scan에서 사용)

OS 레벨에선 보통 1MB씩 I/O → Oracle은 8KB \* 128 = 1MB까지 가능<br>
단, 익스텐트 경계는 넘지 못함

---

### 1.3.7 Table Full Scan vs Index Range Scan

* **Table Full Scan** : 테이블 전체 블록 읽음, Multiblock I/O 기반<br>
* **Index Range Scan** : 인덱스를 통해 필요한 범위만 읽고, 테이블 ROWID로 접근

대량 데이터에서는 오히려 Full Scan이 빠름<br>
→ Index는 반복적인 블록 액세스로 비효율일 수도 있음

---

### 1.3.8 캐시 탐색 메커니즘

DB는 항상 먼저 버퍼 캐시에서 블록을 찾음
→ 없으면 디스크 접근
→ Direct Path I/O 아닌 이상 전부 버퍼 캐시 경유

버퍼 캐시는 해시 구조로 되어 있음 → 탐색 중 동시에 다른 프로세스가 접근하면 충돌 발생
→ **래치(Latch)** 라는 직렬화 메커니즘으로 제어함

버퍼 자체에도 락 존재함 (Buffer Lock)
→ SQL 튜닝 = 결국 I/O 줄이기임
