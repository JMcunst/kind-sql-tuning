<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>친절한 SQL 튜닝 정리</title>
  <style>
    body { font-family: 'Pretendard', sans-serif; line-height: 1.7; padding: 20px; background: #f9f9f9; color: #333; }
    h1, h2, h3, h4 { color: #2c3e50; }
    code { background-color: #eef; padding: 2px 4px; border-radius: 4px; }
    ul { margin-left: 20px; }
    .section { background: #fff; border: 1px solid #ddd; padding: 20px; border-radius: 8px; margin-bottom: 20px; }
  </style>
</head>
<body>

  <h1>📘 친절한 SQL 튜닝 정리</h1>

  <div class="section">
    <h2>1.1 SQL 파싱과 최적화</h2>
    <h3>1.1.1 구조적, 집합적, 선언적 질의 언어</h3>
    <ul>
      <li>SQL은 구조적(structured), 집합적(set-based), 선언적(declarative) 언어</li>
      <li>절차는 옵티마이저가 대신 구성 → 내부적으로는 프로시저 기반 처리</li>
    </ul>

    <h3>1.1.2 SQL 최적화 과정</h3>
    <ul>
      <li><strong>SQL 파싱:</strong> 파싱 트리 생성 → 문법(Syntax) 및 의미(Semantic) 오류 체크</li>
      <li><strong>SQL 최적화:</strong> 옵티마이저가 통계 정보 기반 실행 계획 생성 및 비교</li>
      <li><strong>로우 소스 생성:</strong> 실행 가능한 프로시저 코드로 변환</li>
    </ul>

    <h3>1.1.3 SQL 옵티마이저</h3>
    <ul>
      <li>사용자의 요구를 최적 경로로 수행하기 위한 핵심 엔진</li>
      <li>여러 실행 계획 탐색 → 예상 비용 계산 → 최저 비용 계획 선택</li>
    </ul>

    <h3>1.1.4 실행 계획과 비용</h3>
    <ul>
      <li>실행 계획은 트리 형태로 표현되며, SQL의 처리 절차를 시각화</li>
    </ul>

    <h3>1.1.5 옵티마이저 힌트</h3>
    <ul>
      <li>SQL 내 주석 형태로 사용: <code>/*+ INDEX(테이블 인덱스명) */</code></li>
      <li>실행 계획을 개발자가 제어할 수 있도록 도와줌</li>
    </ul>
  </div>

  <div class="section">
    <h2>1.2 SQL 공유 및 재사용</h2>
    <h3>1.2.1 소프트 파싱 vs 하드 파싱</h3>
    <ul>
      <li><strong>Library Cache:</strong> SQL과 실행계획, 프로시저 캐시 영역</li>
      <li><strong>소프트 파싱:</strong> 캐시에 있는 로우 소스 재사용</li>
      <li><strong>하드 파싱:</strong> 캐시에 없으면 파싱부터 최적화까지 전부 수행 (CPU 부담)</li>
    </ul>

    <h3>1.2.2 바인드 변수의 중요성</h3>
    <ul>
      <li>문자열 연결 → 각각 다른 SQL로 인식 → 하드 파싱 반복</li>
      <li><strong>바인드 변수 사용:</strong> 동일 SQL로 인식되어 하드 파싱 1회로 제한</li>
      <li>예: <code>SELECT * FROM CUSTOMER WHERE LOGIN_ID = ?</code></li>
    </ul>
  </div>

  <div class="section">
    <h2>1.3 데이터 저장 구조 및 I/O 메커니즘</h2>
    <h3>1.3.1 SQL이 느린 이유</h3>
    <ul>
      <li><strong>디스크 I/O</strong>가 느림 → SQL 성능의 주범</li>
    </ul>

    <h3>1.3.2 데이터베이스 저장 구조</h3>
    <ul>
      <li><strong>블록:</strong> 읽기/쓰기 기본 단위 (Oracle: 기본 8KB)</li>
      <li><strong>익스텐트:</strong> 블록의 묶음, 공간 확장 단위</li>
      <li><strong>세그먼트:</strong> 테이블, 인덱스 등 데이터 저장 객체</li>
      <li><strong>테이블스페이스:</strong> 세그먼트를 담는 논리적 공간</li>
    </ul>

    <h3>1.3.3 블록 단위 I/O</h3>
    <ul>
      <li>레코드 하나를 위해 블록 전체를 읽어야 함</li>
      <li>인덱스도 블록 단위로 접근</li>
    </ul>

    <h3>1.3.4 시퀀셜 vs 랜덤 액세스</h3>
    <ul>
      <li><strong>시퀀셜 액세스:</strong> 블록들을 연속적으로 읽음 (풀스캔 등)</li>
      <li><strong>랜덤 액세스:</strong> 순서 없이 특정 블록을 직접 접근</li>
    </ul>

    <h3>1.3.5 논리적 I/O vs 물리적 I/O</h3>
    <ul>
      <li><strong>논리적 I/O:</strong> 메모리 버퍼캐시에서 읽음</li>
      <li><strong>물리적 I/O:</strong> 디스크에서 직접 읽음 → 느림</li>
      <li><strong>BCHR (Buffer Cache Hit Ratio):</strong> 99% 이상 목표</li>
    </ul>

    <h3>1.3.6 Single vs Multi Block I/O</h3>
    <ul>
      <li><strong>Single:</strong> 인덱스 기반, 소량 읽기</li>
      <li><strong>Multi:</strong> Full Scan 등에 적합, 한번에 여러 블록 적재</li>
      <li>최대 1MB (8KB * 128)</li>
    </ul>

    <h3>1.3.7 Table Full Scan vs Index Range Scan</h3>
    <ul>
      <li><strong>Full Scan:</strong> 테이블 전체 블록 읽기 → 대용량일 때 효율</li>
      <li><strong>Index Range Scan:</strong> 인덱스 범위 스캔 후 테이블 접근</li>
    </ul>

    <h3>1.3.8 캐시 탐색 메커니즘</h3>
    <ul>
      <li>DB 버퍼 캐시는 <strong>해시 구조</strong>로 관리</li>
      <li>여러 프로세스가 공유하므로 <strong>래치(Latch)</strong>로 직렬화</li>
      <li>경합이 높아지면 성능 저하 발생</li>
    </ul>
  </div>

</body>
</html>
