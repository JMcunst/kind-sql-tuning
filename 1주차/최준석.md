# SQL 처리 과정과 I/O 메커니즘

## 1.3 데이터 저장 구조 및 I/O 메커니즘

### SQL 성능 저하의 핵심 원인

대부분의 개발자들이 "SQL이 느리다"라고 말할 때, 보통 인덱스가 없거나 WHERE 조건이 잘못되었다고 생각합니다. 하지만 실제 성능 문제의 원인은 더 깊은 곳에 있습니다.

#### 성능 저하의 실질적 원인

**1. 디스크 I/O가 최대 병목점**

- SQL 성능 저하의 가장 주된 원인은 바로 **디스크 I/O**
- I/O = 대기 시간: 운영체제가 I/O를 처리하는 동안 프로세스는 대기 상태로 전환
- 디스크에서 데이터를 읽어와야 할 때마다 CPU는 OS에게 제어권을 넘기고 I/O 완료까지 대기

**2. 과도한 데이터 접근**

- 쿼리 결과로 필요하지 않은 데이터까지 읽어서 처리하는 경우
- 인덱스가 부적절하거나, 옵티마이저가 비효율적인 실행 계획을 선택

**3. 불필요한 I/O 비용 증가**

- SQL 실행 시 필요 이상으로 많은 데이터 블록에 접근
- 캐시 미스(cache miss)로 인한 반복적인 물리적 디스크 접근

#### I/O 처리 속도

- **단일 블록 I/O**: 평균 10ms → 초당 약 100개 블록 처리 가능
- **SSD 기반 I/O**: 1-2ms

**💡핵심:** SQL이 느리다는 것은 "예상보다 많은 작업을 수행하고 있다"는 의미입니다. 쿼리의 응답 시간만 보고 성능을 판단하기 쉽지만, 실제 시스템 성능의 절반 가량은 "동일한 SQL이 얼마나 반복 실행되는가"와 "불필요한 데이터 읽기를 얼마나 줄이는가"에 달려 있습니다.

### 데이터베이스 물리적 저장 구조

데이터베이스에서 테이블은 단순한 행과 열의 집합이 아닙니다. 실제로는 **디스크에 저장되는 물리적 구조**를 바탕으로 하며, 이러한 저장 방식이 SQL 성능에 직접적인 영향을 미칩니다.

#### 계층적 저장 아키텍처

**1. 테이블스페이스(Tablespace)**

- 논리적 저장 단위의 최상위 컨테이너
- 여러 데이터 파일로 구성되며, 다수의 테이블 또는 인덱스를 포함
- 세그먼트들을 담는 논리적 공간

**2. 세그먼트(Segment)**

- 테이블, 인덱스 등 하나의 객체가 점유하는 전체 공간
- 저장공간이 필요한 오브젝트 (테이블, 인덱스, 파티션, LOB 등)
- 다수의 익스텐트로 구성됨

**3. 익스텐트(Extent)**

- 세그먼트가 점유하는 연속된 블록들의 집합
- 공간 확장의 기본 단위로 점진적 확장이 가능
- 연속적인 블록 배열

**4. 블록(Block)**

- 디스크에서 수행되는 최소 I/O 단위
- 실제 데이터가 저장되는 물리적 공간
- 레코드를 저장하는 최소 단위

**5. 행(Row)**

- 최종적으로 사용자가 접근하는 데이터 레벨
- 하나의 블록에는 여러 개의 행이 존재 가능

#### 저장 구조의 주요 특성

- **한 블록 = 한 테이블**: 하나의 블록에 저장된 모든 레코드는 동일한 테이블 소속
- **한 익스텐트 = 한 테이블**: 익스텐트도 마찬가지로 하나의 테이블이 독점 사용
- **다중 파일 구성**: 하나의 테이블스페이스는 여러 데이터 파일로 구성되어 파일 경합을 최소화

#### 저장 구조 개요

| **구성 요소**  | **역할 및 기능**                    |
| -------------- | ----------------------------------- |
| 블록           | 데이터 읽기/쓰기의 기본 단위        |
| 익스텐트       | 공간 확장 단위, 연속 블록의 집합    |
| 세그먼트       | 저장공간이 필요한 오브젝트          |
| 테이블스페이스 | 세그먼트를 포함하는 논리적 컨테이너 |
| 데이터 파일    | 디스크 상의 실제 OS 파일            |

**💡 핵심심:** 이 구조는 단순한 저장 방식이 아니라, I/O 전략과 접근 방식을 결정하는 성능의 기반입니다. 데이터 입력 패턴이 순차적일수록 블록 배치가 최적화되어 성능이 향상됩니다.

### 블록 기반 I/O 동작 원리

데이터베이스는 모든 디스크 I/O를 블록 단위로 처리합니다. **SQL에서 테이블의 단 하나의 행(row)을 요청하더라도, 디스크는 그 행이 포함된 전체 블록(block)을 읽어옵니다.**

#### 블록 기반 I/O의 특징

**1. 데이터 블록 (Data Block)**

- 디스크 읽기/쓰기의 최소 처리 단위
- Oracle 환경에서는 일반적으로 8KB 또는 16KB 크기로 설정

**2. 블록 내부 구성**

- 한 블록에는 여러 개의 행(row)이 저장됨
- 연속적인 데이터일수록 하나의 블록에 더 많이 저장됨 → 성능 개선 효과

**3. I/O는 항상 블록 단위**

- 불필요한 블록 접근을 최소화하는 것이 쿼리 최적화의 핵심
- 한 블록에 저장 가능한 행 수는 행의 크기와 블록 크기에 비례

#### 실제 동작 예시

**1. 단일 행을 읽어도 블록 전체가 읽힌다**

```sql
SELECT * FROM employees WHERE emp_id = 1001;
```

- emp_id 인덱스를 사용해 빠르게 접근하더라도, 해당 행이 속한 전체 블록을 읽어옴
- 블록에 여러 행이 함께 저장되어 있으면 효율적, 그렇지 않으면 비효율적

**2. 블록 수 확인 (Oracle 예시)**

```sql
SELECT table_name, blocks
FROM user_tables
WHERE table_name = 'ORDERS';
```

→ ORDERS 테이블이 몇 개의 블록에 걸쳐 저장되어 있는지 확인 가능

#### 최적화 전략

- 자주 접근하는 컬럼만 별도로 분리하여 I/O 감소 (hot column 분리)
- 블록이 연속적으로 배치되어 있으면 성능 향상 (블록 조각화 방지)

> **💡 핵심:** 데이터베이스는 사용자에게 레코드 기반의 인터페이스를 제공하지만, 실제로는 블록 기반의 하드웨어 환경에서 동작합니다. "몇 건을 읽었는가?"보다는 "몇 개의 블록을 읽었는가?"가 성능의 실제 지표입니다.

### 시퀀셜 액세스 vs 랜덤 액세스

데이터베이스에서 데이터를 읽는 방식은 크게 두 가지 접근법으로 나뉩니다.

#### 시퀀셜 액세스 (Sequential Access)

**정의:**

- 디스크 상에서 **연속된 블록들을 순서대로 읽는 접근 방식**
- 논리적 또는 물리적으로 연결된 순서를 따라 차례대로 블록을 읽음

**주요 특징:**

- **Full Table Scan**과 같이 대량의 데이터를 연속적으로 읽을 때 주로 사용
- **디스크 헤드 이동이 최소화**되어 **처리량(throughput)이 높음**
- **멀티블록 I/O**에 최적화됨

**동작 메커니즘:**

- **Full Table Scan**: 익스텐트 맵에서 각 익스텐트의 첫 번째 블록 주소를 획득한 후, 해당 익스텐트의 연속된 블록들을 순서대로 읽는 방식

#### 랜덤 액세스 (Random Access)

**정의:**

- 디스크 상의 **임의 위치에 있는 블록들을 점프하며 읽는 접근 방식**
- 논리적, 물리적 순서와 무관하게 개별 레코드를 위해 한 블록씩 접근

**주요 특징:**

- **인덱스 기반 조회(Index Scan)**에서 주로 발생
- **디스크 헤드의 빈번한 이동**으로 인해 I/O 효율이 상대적으로 낮음
- 단, **결과 건수가 소량인 경우에는 매우 빠름**

#### 성능 비교 분석

| **항목**        | **시퀀셜 액세스**         | **랜덤 액세스**                 |
| --------------- | ------------------------- | ------------------------------- |
| 접근 방식       | 연속된 블록 순차 읽기     | 임의 블록을 점프하여 읽기       |
| 주요 발생 시점  | Full Scan, Range Scan     | Index Scan, Key Lookup          |
| 성능 특성       | 대량 데이터 처리에 최적   | 소량 데이터 조회에 최적         |
| 디스크 I/O 효율 | 우수 (멀티블록 처리 가능) | 상대적으로 낮음 (seek overhead) |

#### 실제 적용 사례

**1. 시퀀셜 액세스 (Full Table Scan)**

```sql
SELECT * FROM sales WHERE year = 2024;
```

- year 컬럼에 인덱스가 없다면, 전체 테이블을 **순차적으로 블록별로 스캔**
- 블록이 연속적으로 저장되어 있을 경우 빠른 처리 가능

**2. 랜덤 액세스 (Index Lookup)**

```sql
SELECT * FROM users WHERE user_id = 1001;
```

- 인덱스를 통해 해당 키를 검색한 후, **해당 행이 위치한 블록에 랜덤하게 접근**
- 조회 대상이 증가할수록 디스크 I/O가 증가하여 **성능 저하 가능성**

#### 최적화 가이드라인

- **대량 데이터 검색**에는 Full Scan이 오히려 더 효율적일 수 있음
- **결과 건수에 따라** 접근 방식이 달라짐 → 옵티마이저의 판단 기준
- 디스크 기반 DB에서는 시퀀셜이 유리하지만, SSD 환경에서는 랜덤 접근의 성능 차이가 감소

> **💡 핵심:** I/O는 단순한 속도의 문제가 아니라 물리적 구조의 문제입니다. 시퀀셜은 "책을 순서대로 넘기는 것", 랜덤은 "책의 임의 페이지를 계속 찾아가는 것"과 같습니다. 결국, 데이터의 배치와 접근 빈도에 따라 어느 방식이 더 효율적인지는 결정되며, SQL 튜닝은 단순히 '인덱스 사용 여부'의 문제가 아니라, '순차적 읽기가 가능한 환경을 만드는가'의 설계 문제입니다.

### 논리적 I/O vs 물리적 I/O

SQL이 데이터를 읽는 과정에서 발생하는 I/O는 크게 두 가지 형태로 구분됩니다.

#### 논리적 I/O (Logical I/O)

**정의:**

- 데이터베이스의 **버퍼 캐시(buffer cache)**에서 데이터를 읽는 작업
- 디스크까지 접근하지 않고 **메모리에 이미 적재된 블록을 읽는 경우**

**주요 특징:**

- 성능에 큰 영향을 주지 않음
- SQL이 빠르게 응답하는 경우 대부분 이 방식으로 처리됨
- SQL 처리 과정에서 메모리 버퍼 캐시에서 발생하는 총 블록 I/O

#### 물리적 I/O (Physical I/O)

**정의:**

- **디스크에서 블록을 직접 읽어오는 작업**
- 캐시에 해당 블록이 존재하지 않아 디스크까지 접근해야 하는 경우

**주요 특징:**

- **가장 비용이 높은 I/O 작업**
- 디스크에서 발생한 총 블록 I/O
- 메모리는 디스크에 비해 약 **10,000배 빠른 처리 속도**를 제공

#### I/O 관계식

- **물리적 I/O = 논리적 I/O × (100 - BCHR) / 100**
- **BCHR (Buffer Cache Hit Rate)**: 버퍼 캐시 히트율

#### 성능 비교 분석

| **항목**    | **논리적 I/O**       | **물리적 I/O**           |
| ----------- | -------------------- | ------------------------ |
| 데이터 위치 | 메모리(Buffer Cache) | 디스크                   |
| 처리 속도   | 빠름                 | 느림 (디스크 접근 필요)  |
| 비용        | 낮음                 | 높음                     |
| 발생 조건   | 데이터가 캐시에 존재 | 캐시 미스 시 디스크 읽기 |
| 성능 영향   | 낮음                 | 높음                     |
| 제어 가능성 | 제어 가능            | 직접적 제어 어려움       |

#### 실제 적용 사례

**1. 논리적 I/O 중심 처리 (캐시 히트)**

```sql
-- 자주 조회되어 이미 캐시에 적재된 설정 정보
SELECT * FROM config_settings WHERE setting_name = 'theme';
```

- 설정 정보와 같이 자주 읽히는 테이블은 대부분 캐시에 상주
- 물리적 I/O 없이 버퍼에서 처리되므로 매우 빠른 응답 시간

**2. 물리적 I/O 발생 (캐시 미스)**

```sql
-- 수백만 건의 로그 테이블, 조건 없이 전체 조회
SELECT * FROM audit_log;
```

- 최초 조회되는 대용량 테이블은 버퍼에 없으므로 디스크에서 직접 읽기
- 수천~수만 개의 물리적 I/O를 유발하여 성능 저하의 주요 원인

#### 튜닝 관점에서의 접근

**논리적 I/O 최적화가 핵심:**

- SQL 튜닝이란 **논리적 I/O를 감소시켜 읽어오는 블록 자체를 줄이는 것**
- 물리적 I/O는 매 요청마다 가변적이므로 튜닝의 직접적 대상이 되기 어려움
- **논리적 I/O 자체를 감소시키면 제어 불가능한 물리적 I/O도 자연스럽게 감소**

**BCHR의 함정:**

- 버퍼 캐시 히트율(BCHR)이 높다고 반드시 효율적인 SQL은 아님
- 동일한 블록을 비효율적으로 반복 읽으면 BCHR은 향상되지만 성능은 저하될 수 있음

#### DB별 분석 도구

- **Oracle**: v$sql, v$session_event, AUTOTRACE
- **PostgreSQL**: pg*statio*\* 뷰
- **MySQL**: Performance Schema

> **💡 핵심:** 데이터는 항상 논리적으로 읽히지만, 실제로는 물리적으로 읽는 순간 성능 병목이 시작됩니다. 성능 저하는 새로운 SQL을 작성해서가 아니라, 기존 SQL이 캐시에 없는 상태에서 실행되면서 시작됩니다. SQL 튜닝은 단순히 쿼리를 줄이는 것이 아니라, 디스크를 건드릴 필요가 없도록 만드는 설계의 예술입니다.

### Single Block I/O vs Multiblock I/O

데이터베이스는 디스크에서 데이터를 읽을 때 **한 번에 몇 개의 블록을 읽을 것인가**를 전략적으로 결정합니다.

#### Single Block I/O (단일 블록 I/O)

**정의:**

- **한 번에 하나의 블록만 읽는 처리 방식**

**주요 특징:**

- 주로 **인덱스를 통한 랜덤 액세스**나 **정확한 조회**에서 사용
- 특정 행을 빠르게 찾아야 할 때 적합
- **반복 호출이 많은 경우 성능 저하** 가능성
- 인덱스와 테이블 블록 모두 Single Block I/O 방식 (소량 데이터 검색 시)

#### Multiblock I/O (다중 블록 I/O)

**정의:**

- 한 번의 I/O 요청으로 **여러 개의 연속된 블록을 동시에 읽는 방식**

**주요 특징:**

- 주로 **Full Table Scan**이나 **시퀀셜 액세스**에서 사용
- **대량 처리 시 매우 효율적**
- Oracle의 경우 `db_file_multiblock_read_count` 파라미터로 최대 블록 수 조정
- 대용량 테이블 전체 스캔 시 Multiblock I/O 방식 활용

#### 성능 비교 분석

| **항목**       | **Single Block I/O**   | **Multiblock I/O**                       |
| -------------- | ---------------------- | ---------------------------------------- |
| 처리 단위      | 1개 블록               | 여러 개의 연속 블록                      |
| 주요 사용 시점 | 인덱스 탐색, 랜덤 접근 | Full Table Scan, 시퀀셜 처리             |
| 성능 특성      | 정확한 조회에 유리     | 대량 처리에 유리                         |
| 오버헤드       | 반복 호출 시 비용 증가 | 한번에 처리하므로 상대적으로 적음        |
| 제어 파라미터  | 없음                   | `db_file_multiblock_read_count` (Oracle) |

#### 실제 적용 사례

**1. Single Block I/O (Index Access)**

```sql
SELECT * FROM employees WHERE employee_id = :1;
```

- 옵티마이저는 인덱스를 사용해 해당 키에 대한 단일 블록을 읽음
- 수천 건을 반복적으로 조회하면, 많은 I/O 호출이 발생하여 성능 저하 가능

**2. Multiblock I/O (Full Scan)**

```sql
SELECT * FROM employees WHERE department_id = 10;
```

- 조건이 인덱스에 적합하지 않거나 많은 건수를 반환할 경우 Full Scan으로 전환
- 이 경우 여러 블록을 한꺼번에 읽어오는 방식으로 처리됨

#### 성능 최적화 관점

**대기 횟수를 줄이는 전략:**

- 읽고자 하는 블록을 DB 버퍼 캐시에서 찾지 못하면 해당 블록을 디스크에서 읽기 위해 I/O Call 발생
- 그 동안 프로세스는 대기 큐에서 대기 상태로 전환
- **기왕 대기를 하려면 한꺼번에 많은 양을 요청해야 대기 횟수를 줄이고 성능을 향상시킬 수 있음**
- 대용량 Full Scan 시, Multiblock I/O 단위를 크게 설정하면 성능 개선

#### 최적화 가이드라인

- 데이터가 순차적으로 저장되어 있다면 Multiblock I/O가 더 유리
- 인덱스를 맹신하지 말고, 처리 대상의 양에 따라 I/O 전략이 달라질 수 있음을 고려
- 대용량 데이터를 반복 조회하는 쿼리는 배치 처리 또는 캐시 전략 필요

> **💡 핵심:** I/O의 단위는 보이지 않지만, 성능은 그에 따라 결정됩니다. 쿼리는 단순해 보이지만, 실제로는 수천 번의 블록 읽기가 발생할 수 있습니다. 결국, "한 번에 얼마나 많이 읽을 수 있는가"는 데이터베이스 성능 최적화의 핵심 전략 중 하나입니다. 블록 수를 줄이는 것만큼, I/O 단위를 최적화하는 것 역시 중요한 성능 설계 요소입니다.

### Table Full Scan vs Index Range Scan

SQL에서 데이터를 검색할 때 사용되는 가장 대표적인 두 가지 접근 방식입니다.

#### Table Full Scan

**정의:**

- 테이블의 모든 블록을 처음부터 끝까지 읽는 방식

**주요 특징:**

- **Sequential Access** (순차 접근) 방식
- **Multiblock I/O** 처리
- **대량 데이터 검색 시 유리**
- 조건절이 인덱스를 활용할 수 없거나, 조회 대상이 테이블 전체의 상당한 비율을 차지할 때 옵티마이저가 선택
- 연속된 블록을 순차적으로 읽어 높은 처리량 제공

#### Index Range Scan

**정의:**

- 인덱스를 활용하여 특정 범위의 레코드를 찾아가는 방식

**주요 특징:**

- **Random Access** (랜덤 접근) 방식
- **Single Block I/O** 처리
- **소량 데이터 검색 시 유리**
- 인덱스에 정의된 컬럼 조건이 WHERE절에 명확히 명시된 경우 사용
- 결과가 소량인 경우 매우 빠른 응답
- 레코드 발견 후에도 테이블에서 실제 데이터 블록을 읽는 추가 I/O 발생 (table access by ROWID)

#### 성능 비교 분석

| **항목**         | **Table Full Scan**                  | **Index Range Scan**                |
| ---------------- | ------------------------------------ | ----------------------------------- |
| 접근 방식        | 전체 테이블 블록 순차 읽기           | 인덱스를 통한 특정 범위 접근        |
| I/O 방식         | Multiblock I/O                       | 주로 Single Block I/O + ROWID 탐색  |
| 성능 특성        | 조회 건수가 많을수록 유리            | 조회 건수가 적을수록 유리           |
| 인덱스 필요 여부 | 불필요                               | 필수                                |
| 예외적 사용 예시 | 인덱스 존재해도 조건이 부적절한 경우 | 바인드 피킹에 따라 비효율 발생 가능 |

#### 실제 적용 사례

**1. Table Full Scan**

```sql
SELECT * FROM products WHERE UPPER(name) = 'DESK';
```

- 인덱스가 존재하더라도 `UPPER(name)`처럼 함수를 사용하면 인덱스 무력화
- 옵티마이저는 Full Scan을 선택

**2. Index Range Scan**

```sql
SELECT * FROM orders WHERE order_date BETWEEN :start AND :end;
```

- order_date에 인덱스가 존재하면, 옵티마이저는 해당 범위만 인덱스를 통해 추출
- 빠른 결과 도출 가능

#### Index Range Scan 세부 과정

1. **인덱스에서 "특정 범위"를 스캔**하면서 ROWID 획득
2. **획득한 ROWID로 테이블 레코드를 찾아가는 방식**
   - ROWID: 테이블 레코드가 디스크 상에 어디 저장되어 있는지를 가리키는 위치 정보

#### 최적화 가이드라인

- 함수, 연산, 형 변환 등이 WHERE절에 포함되면 **인덱스가 무효화될 수 있음**

```sql
-- 비효율적인 예
WHERE TO_CHAR(order_date, 'YYYY-MM-DD') = '2025-05-14'

-- 개선된 예
WHERE order_date BETWEEN TO_DATE('2025-05-14', 'YYYY-MM-DD')
                    AND TO_DATE('2025-05-14', 'YYYY-MM-DD') + 1
```

- Full Scan은 부정적인 것이 아니라, **조건이 광범위하거나 결과가 많은 경우 합리적 선택**
- **Table Full Scan이 항상 성능 저하를 의미하는 것은 절대 아님** (대량 데이터 검색 시에는 더 효율적)

#### 분석 도구

- **Oracle**: AUTOTRACE, DBMS_XPLAN.DISPLAY_CURSOR로 실제 선택된 방식 확인

> **💡 핵심:** Full Scan과 Index Scan은 속도의 문제가 아니라 전략의 차이입니다. 인덱스를 맹신해서는 안 됩니다. 오히려 잘못된 인덱스 접근은 무수한 랜덤 I/O를 초래하여 성능을 악화시킬 수 있습니다. 옵티마이저가 어떤 전략을 선택했는지 이해하고, 그 이유를 설명할 수 있어야 진정한 튜닝을 할 수 있습니다. 그리고 때로는 인덱스를 제거하는 것이 더 빠를 수도 있다는 점을 기억해야 합니다.

### 캐시 탐색 메커니즘

데이터베이스는 디스크 I/O 비용을 줄이기 위해 메모리 캐시를 적극적으로 활용합니다. 이 메커니즘은 SQL 성능에 절대적인 영향을 끼치며, 특히 동일한 데이터를 여러 번 읽는 환경에서 큰 차이를 만들어냅니다.

#### DBMS의 주요 캐시 영역

**1. 버퍼 캐시 (Buffer Cache)**

- 디스크에서 읽은 **데이터 블록을 저장하는 메모리 공간**
- 다음 번 동일 블록 요청 시 **물리적 I/O 없이 논리적 I/O만 수행**
- 디스크에서 읽은 데이터 블록을 캐싱하여 동일 블록에 대한 반복적인 I/O 콜을 감소

**2. 라이브러리 캐시 (Library Cache)**

- **SQL 문장의 파싱 결과와 실행 계획**이 저장되는 공간
- 동일한 SQL이 들어왔을 때 **하드 파싱 없이 소프트 파싱으로 처리**
- SQL과 실행계획, DB 저장형 함수/프로시저 등을 캐싱하는 "코드 캐시"

**3. 데이터 딕셔너리 캐시 (Dictionary Cache)**

- 테이블, 컬럼, 사용자 권한 등 **시스템 메타데이터 정보**를 캐싱

#### 캐시 탐색 프로세스

1. **SQL 문장이 캐시에 있는지 확인** (Library Cache)
2. **실행 계획이 있다면 해당 블록이 Buffer Cache에 있는지 확인**
3. **없다면 디스크에서 읽어 Buffer Cache에 적재**
4. **이후 동일 블록 요청 시 메모리에서 탐색**

#### 버퍼 캐시 탐색 메커니즘

**탐색 과정:**

1. **해시 함수를 사용**해서 나온 결과로 링크드 리스트 헤더를 찾음
2. **찾으려고 하는 블록이 나올 때까지 리스트 탐색**
3. **발견하면 처리 완료**
4. **없다면 디스크로부터 읽어서 리스트에 추가**

**동시성 제어:**

- 버퍼 캐시는 SGA의 구성 요소로 캐싱된 버퍼 블록들은 공유 자원
- 여러 프로세스로부터 동시에 특정 블록에 접근하는 경우 발생
- **자원을 공유하는 것처럼 보여도 실제로 내부에서는 한 프로세스씩 순차적으로 접근하도록 직렬화 제공**
- **캐시버퍼 체인 래치(Latch)**를 통해 각각의 링크드 리스트마다 락을 걸어 동시성 제어

#### 실제 적용 사례

**1. 동일 쿼리 반복 시 성능 차이**

```sql
-- 대량 데이터 첫 실행 (물리적 I/O 발생)
SELECT * FROM sales WHERE year = 2024;
-- 동일 쿼리 두 번째 실행 (Buffer Cache에서 처리)
SELECT * FROM sales WHERE year = 2024;
```

- **첫 번째 실행**: 디스크에서 블록 읽기 (물리적 I/O)
- **두 번째 실행**: 메모리에서 탐색 (논리적 I/O) → 수 ms 내 응답

#### 캐시 최적화 전략

**1. 캐시 친화적 설계**

- 자주 사용하는 쿼리와 테이블은 캐시에 머무를 수 있는 구조로 설계
- 정기적 조회 대상 → 조회 전 warm-up 고려

**2. 캐시 히트율 모니터링**

- **Oracle**: v$buffer_pool_statistics 뷰
- **PostgreSQL**: pg*statio*\* 뷰 사용

**3. 캐시 효과 저해 요소 회피**

- 사용자 정의 함수(UDF)나 비정형 쿼리는 캐시 효과를 저해
- 정형화된 SQL 작성 권장

#### 성능 최적화 관점

**버퍼 캐시 탐색도 비용:**

- 버퍼 캐시를 탐색하는 것도 래치에 의해서 느릴 수 있음
- 따라서 **버퍼 캐시조차 접근하는 것을 줄여야 함**
- 즉, **논리적 I/O를 줄여야 함**

**캐시의 한계:**

- 동일한 블록을 비효율적으로 반복해서 읽으면 버퍼 캐시 히트율은 향상되지만 성능은 저하
- 캐시 히트율이 높다고 해서 반드시 효율적인 SQL은 아님

> **💡 핵심:** "느린 쿼리도 두 번 돌리면 빨라지는 이유"는 대부분 캐시 덕분입니다. 데이터베이스 성능의 핵심은 디스크를 덜 사용하고 메모리를 더 사용하게 만드는 것입니다. 그리고 그 메모리를 효과적으로 활용하기 위한 장치가 바로 캐시 탐색 메커니즘입니다. 쿼리는 언제나 느리게 시작하고, 반복될수록 빨라집니다. 이 반복의 효과를 극대화하려면, 잘 설계된 캐시 유도 전략이 필요합니다. 튜닝은 단지 쿼리를 줄이는 게 아니라, 시스템이 기억할 수 있는 쿼리를 작성하는 것입니다.

## 마무리

SQL 튜닝의 첫 걸음은 SQL이 내부적으로 어떻게 동작하는지를 이해하는 것입니다. 이 장에서 살펴본 내용들은 단순한 이론이 아니라, 실제 성능 문제를 해결하는 데 필요한 핵심 지식입니다.

### 핵심 원칙 정리

**1. SQL은 구조적, 집합적, 선언적 언어**

- 무엇을 원하는지만 선언하면, 어떻게 할지는 옵티마이저가 결정

**2. 파싱 최적화**

- 소프트 파싱을 유도하기 위해 바인드 변수 사용 필수
- 하드 파싱은 CPU 자원을 낭비하는 주요 원인

**3. I/O가 성능의 핵심**

- SQL이 느린 근본적인 이유는 디스크 I/O
- 논리적 I/O를 줄이는 것이 튜닝의 핵심

**4. 블록 단위로 사고하기**

- 데이터는 행 단위로 보이지만 블록 단위로 읽힘
- 얼마나 많은 블록을 읽느냐가 성능을 결정

**5. 접근 방식의 선택**

- 시퀀셜 vs 랜덤, Full Scan vs Index Scan
- 데이터 양과 조건에 따라 최적의 방식이 달라짐

**6. 캐시 활용**

- 메모리 캐시를 효과적으로 활용하는 것이 성능의 열쇠
- 물리적 I/O를 논리적 I/O로 바꾸는 것이 목표

### 실무 적용 지침

#### **SQL 작성 시:**

✓ 바인드 변수 사용을 습관화  
✓ 함수나 연산으로 인한 인덱스 무력화 주의  
✓ WHERE 조건의 선택도 고려

#### **성능 분석 시:**

✓ 실행 계획을 통해 접근 방식 확인  
✓ 논리적 I/O와 물리적 I/O 분석  
✓ 캐시 히트율과 함께 전체적인 I/O 패턴 파악

#### **튜닝 전략:**

✓ 인덱스가 항상 최선은 아님을 인지  
✓ 데이터 특성과 조회 패턴에 맞는 접근 방식 선택  
✓ 시스템 전체의 캐시 전략 고려
